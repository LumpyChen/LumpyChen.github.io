<!DOCTYPE html><html lang="en,zh-cn,default"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 正则表达式快速入门 · LANTAU</title><meta name="description" content="教你快速学会这个你知道干什么用却懒得学的东西。"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://lumpychen.github.io/atom.xml" title="LANTAU"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link active">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.zhihu.com/people/irvingchen" target="_blank" class="nav-list-link">ZHIHU</a></li><li class="nav-list-item"><a href="www.lumpychen.com/cv" target="_self" class="nav-list-link">RESUME</a></li><li class="nav-list-item"><a href="https://github.com/lumpychen" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">正则表达式快速入门</h1><div class="post-info">2016年9月26日</div><div class="post-tags"><a href="/tags/develop/" class="post-tag"> develop</a></div><div class="post-content"><link rel="stylesheet" href="/owl.css"><p>我们都爱正则表达式，但是一个个奇怪字符的组合总是让我这种弱鸡感到难以领悟。</p>
<p>每次看到一个正则匹配式却理解不了，我都安慰自己：“反正我已经知道它是用来匹配文本的”</p>
<p>为什么不现在直接把它学会呢？</p>
<a id="more"></a>
<hr>
<p>首先推一个可以帮助你理解正则的网站<a href="https://regexper.com" target="_blank" rel="external">正则表达式可视化</a></p>
<p>还有一个 Atom 插件 <a href="https://atom.io/packages/regex-railroad-diagram" target="_blank" rel="external">regex-railroad-diagram</a></p>
<p>这样的可视化模型可以帮助你快速回忆与熟悉正则字符的含义。</p>
<h2 id="1-字符"><a href="#1-字符" class="headerlink" title="1.字符"></a>1.字符</h2><p>正则表达式中我们可以使用两种字符：</p>
<ul>
<li>原义字符：原义文本字符代表字符本身的匹配</li>
<li>元字符：元字符是正则表达式中有特殊含义的字符，其组合代表特殊字符或者其他逻辑</li>
</ul>
<p>在正则表达式中以下字符有特殊含义，为元字符<br>所以只有转义之后它们才能作为原义文本字符来使用：</p>
<p><code>*</code>, <code>+</code>, <code>?</code>, <code>$</code>, <code>^</code>, <code>.</code>, <code>|</code>, <code>\</code>, <code>()</code>, <code>[]</code>, <code>{}</code></p>
<p>比如你想要匹配字符串中出现的<code>$</code>, 必须在正则表达式中使用<code>\$</code>进行转义</p>
<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>这几个组合而成的元字符组合会匹配相应特殊字符：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">匹配特殊字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\t</code></td>
<td style="text-align:center">制表符</td>
</tr>
<tr>
<td style="text-align:center"><code>\v</code></td>
<td style="text-align:center">垂直制表符</td>
</tr>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td style="text-align:center">换行符</td>
</tr>
<tr>
<td style="text-align:center"><code>\r</code></td>
<td style="text-align:center">回车</td>
</tr>
<tr>
<td style="text-align:center"><code>\f</code></td>
<td style="text-align:center">换页</td>
</tr>
<tr>
<td style="text-align:center"><code>c*</code></td>
<td style="text-align:center">Ctrl+特定字符</td>
</tr>
</tbody>
</table>
<h2 id="2-字符匹配方式"><a href="#2-字符匹配方式" class="headerlink" title="2.字符匹配方式"></a>2.字符匹配方式</h2><p>我们先做出在全局模式的进行匹配的假设</p>
<p>全局模式会在下一章节进行介绍</p>
<h4 id="正常匹配："><a href="#正常匹配：" class="headerlink" title="正常匹配："></a>正常匹配：</h4><p>在正则表达式中使用原义字符或组合成的特殊字符会正常匹配相应字符</p>
<p>在正则表达式中使用<code>a</code>会匹配文本<code>a1b2ab3</code>中第一个字符<code>a</code>和倒数第三个字符<code>a</code></p>
<h4 id="字段匹配："><a href="#字段匹配：" class="headerlink" title="字段匹配："></a>字段匹配：</h4><p>在正则表达式中使用连续的原义字符或组合而成的特殊字符会匹配相应字符组合</p>
<p>在正则表达式中使用<code>ab</code>会匹配文本<code>a1b2ab3</code>中倒数第二三个字符<code>ab</code></p>
<h4 id="类匹配："><a href="#类匹配：" class="headerlink" title="类匹配："></a>类匹配：</h4><p>在正则表达式中使用元字符：</p>
<p><code>[]</code>: 创建<em>类</em>将匹配<code>[]</code>中的任意字符</p>
<p>类中字符的连写代表<em>或</em>的关系——满足连写的字符其中一者就将会被匹配</p>
<p>正则表达式中使用<code>[ab]</code>会匹配文本<code>a1b2ab3</code>中所有的<code>a</code>与<code>b</code>字符</p>
<p>特殊的 <em>类</em>：</p>
<ul>
<li><code>[^]</code>: 反相匹配——匹配不是<code>[^</code>和<code>]</code>中的任意字符</li>
<li><code>[a-z]</code>: 小写字母匹配——从<code>a</code>到<code>z</code>的小写英文字符</li>
<li><code>[A-Z]</code>: 大写字母匹配——从<code>A</code>到<code>Z</code>的大写英文字符</li>
<li><code>[0-9]</code>: 数字匹配——从<code>0</code>到<code>9</code>的数字字符</li>
</ul>
<p>同时有一些等价的元字符方便使用：</p>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">等价类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">[^\r\n]</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:center">[0-9]</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:center">[^0-9]</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:center">[\t\n\v\f\r]</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td style="text-align:center">[^\t\n\v\f\r]</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:center">[a-zA-Z_0-9]</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:center">[^a-zA-Z_0-9]</td>
</tr>
</tbody>
</table>
<p>具体什么含义？根据之前的线索推断一下吧 : )</p>
<h4 id="量匹配"><a href="#量匹配" class="headerlink" title="量匹配"></a>量匹配</h4><p>有的时候，正则表达式需要对字符出现次数进行匹配，此时我们需要使用量匹配的元字符</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center">最多出现一次</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">至少出现一次</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">出现任意次</td>
</tr>
<tr>
<td style="text-align:center"><code>{n}</code></td>
<td style="text-align:center">出现n次</td>
</tr>
<tr>
<td style="text-align:center"><code>{n,m}</code></td>
<td style="text-align:center">出现n到m次</td>
</tr>
<tr>
<td style="text-align:center"><code>{n,}</code></td>
<td style="text-align:center">至少出现n次</td>
</tr>
</tbody>
</table>
<p>量匹配的元字符跟随在字符的后面生效，比如</p>
<p><code>T\d?</code>匹配后面最多出现一次数字字符的字符<code>T</code></p>
<h4 id="边界匹配"><a href="#边界匹配" class="headerlink" title="边界匹配"></a>边界匹配</h4><p>边界匹配是采用元字符的一种特殊匹配方式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">匹配行首的边界</td>
</tr>
<tr>
<td style="text-align:center"><code>$</code></td>
<td style="text-align:center">匹配行末的边界</td>
</tr>
<tr>
<td style="text-align:center"><code>\b</code></td>
<td style="text-align:center">匹配单词边界</td>
</tr>
<tr>
<td style="text-align:center"><code>\B</code></td>
<td style="text-align:center">匹配非单词边界</td>
</tr>
</tbody>
</table>
<p>这些字符本身并不匹配字符，匹配的是特定的边界</p>
<p>在字符串<code>There HiThere There</code>中使用</p>
<ul>
<li>正则表达式<code>^</code>/<code>$</code>替换为<code>#</code> —— <code>#There HiThere There</code> 与 <code>There HiThere There#</code></li>
<li>正则表达式<code>^T</code>/<code>e$</code>替换为<code>#</code> —— <code>#here HiThere There</code> 与 <code>There HiThere Ther#</code></li>
<li>正则表达式<code>\b</code>替换为<code>#</code> —— <code>#There# #HiThere# #There#</code></li>
<li>正则表达式<code>\bT</code>替换为<code>#</code> —— <code>#here HiThere #here</code></li>
<li>正则表达式<code>\bThere\b</code> —— 匹配第一个单词<code>There</code>与最后一个单词<code>There</code></li>
<li>正则表达式<code>\BThere\b</code> —— 匹配<code>HiThere</code>里面的<code>There</code></li>
</ul>
<p>根据这些规律的提示，加上你自己的练习，掌握边界匹配不需要太多时间。</p>
<div class="tip"><br>  正则表达式默认会将一段文本中每个换行处转化为<code>\n</code>换行符，而这不会被<code>^</code>和<code>$</code>匹配，除非开启了多行模式。有关多行模式的内容，见下一章节。<br></div>

<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><h2 id="2-JavaScript-中的-RegExp-对象"><a href="#2-JavaScript-中的-RegExp-对象" class="headerlink" title="2.JavaScript 中的 RegExp 对象"></a>2.JavaScript 中的 RegExp 对象</h2><p>在<code>JavaScript</code>中，由<code>/</code>开始，由<code>/</code>结束（或者跟随有效正则修饰符）的字段会被<code>JavaScript</code>编译器正确解析为一个<code>RegExp</code>对象。</p>
<p>同时记得<code>//</code>并不会报出``</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p><code>RegExp</code>是<code>JavaScript</code>中的内置对象，其构造函数创建了一个正则表达式对象，用来匹配文本。</p>
<p>有两种构造方式：</p>
<ul>
<li>字面量方式</li>
<li>构造函数方式</li>
</ul>
<h4 id="字面量方式"><a href="#字面量方式" class="headerlink" title="字面量方式"></a>字面量方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/\bis\b/g</span></div></pre></td></tr></table></figure>
<p><code>RegExp</code>对象的实例由</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\bis\\b'</span>, <span class="string">'g'</span>)</div></pre></td></tr></table></figure>
<p><code>RegExp</code>构造函数接受两个参数：</p>
<ul>
<li>包含正则表达式的一个字符串（注意在字符串中转义符需要转义输入）</li>
<li>包含正则表达式修饰符的一个字符串</li>
</ul>
<p>推荐使用字面量方式进行 <code>RegExp</code> 实例的构建。</p>
<p>####</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/en/Econometrics-OLS/" class="prev">上一篇</a><a href="/2016/en/Econometrics/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 <a href="http://lumpychen.github.io">Lumpy</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>