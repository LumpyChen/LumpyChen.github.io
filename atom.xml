<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LANTAU</title>
  <subtitle>Lavish angel never tell about u.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lumpychen.github.io/"/>
  <updated>2016-10-18T16:06:08.000Z</updated>
  <id>http://lumpychen.github.io/</id>
  
  <author>
    <name>Lumpy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cleaverjs简介</title>
    <link href="http://lumpychen.github.io/2016/zh-cn/Cleaverjs%E7%AE%80%E4%BB%8B/"/>
    <id>http://lumpychen.github.io/2016/zh-cn/Cleaverjs简介/</id>
    <published>2016-10-18T13:29:19.000Z</published>
    <updated>2016-10-18T16:06:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p>本片博客为大家带来<code>Cleaver.js</code>的指南</p>
<p>幻灯片版本的介绍<a href="https://lumpychen.github.io/cleaver_intro/">点这里浏览</a></p>
<a id="more"></a>
<p>–</p>
<h2 id="Cleaver是什么？"><a href="#Cleaver是什么？" class="headerlink" title="Cleaver是什么？"></a>Cleaver是什么？</h2><p>Cleaver 是一个能根据一个 Markdown 文档<strong>快速生成简易 PPT</strong> 的 强大工具</p>
<blockquote>
<p>如果你已经有了一个 Markdown 的文档，30秒就可以制作成幻灯片。</p>
</blockquote>
<p><a href="https://github.com/jdan/cleaver" target="_blank" rel="external">Github戳这里</a></p>
<p>– </p>
<h2 id="厌倦了PPT？"><a href="#厌倦了PPT？" class="headerlink" title="厌倦了PPT？"></a>厌倦了PPT？</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://b-i.forbesimg.com/carminegallo/files/2013/11/6845.strip_.zoom_-e1385136828745.gif" alt=""></h2><h2 id="它的优势之处在于："><a href="#它的优势之处在于：" class="headerlink" title="它的优势之处在于："></a>它的优势之处在于：</h2><ol>
<li>简易而快速</li>
<li>如果你会用 Markdown ，你不需要额外学习</li>
<li>生成静态网页，易于在线分享</li>
<li>移动端同样易于浏览</li>
</ol>
<p>–</p>
<h2 id="使用Cleaver，你需要："><a href="#使用Cleaver，你需要：" class="headerlink" title="使用Cleaver，你需要："></a>使用Cleaver，你需要：</h2><ul>
<li>Cleaver 基于 HTML5，你需要现代的浏览器</li>
<li>Cleaver 需要 nodejs 的环境</li>
<li>使用 Cleaver 需要掌握 Markdown 的语法</li>
</ul>
<p>–</p>
<h2 id="安装Cleaver"><a href="#安装Cleaver" class="headerlink" title="安装Cleaver"></a>安装Cleaver</h2><ol>
<li>下载并安装 <a href="https://nodejs.org/download/" target="_blank" rel="external">node.js</a> （如果需要）</li>
<li>终端里执行以下代码：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install cleaver -g</div></pre></td></tr></table></figure>
<p>等待其安装成功即可</p>
<p>–</p>
<h2 id="使用Cleaver"><a href="#使用Cleaver" class="headerlink" title="使用Cleaver"></a>使用Cleaver</h2><p> Cleaver 和普通的 Markdown 存在一点区别：</p>
<ol>
<li>需要在 Markdown 文件开头添加少量配置，<a href="https://github.com/jdan/cleaver/blob/master/docs/options.md" target="_blank" rel="external">配置的API</a></li>
<li><p>需要在正文中使用<code>--</code>来进行幻灯片的分页</p>
<p>比如这个幻灯片对应的 markdown 文件<a href="https://raw.githubusercontent.com/LumpyChen/cleaver_intro/master/cleaver_demo.md" target="_blank" rel="external">源码在此</a></p>
<p>–</p>
<h2 id="常用配置详解"><a href="#常用配置详解" class="headerlink" title="常用配置详解"></a>常用配置详解</h2><p>|配置名|默认值|含义|<br>|:—:|:—:|:—:|<br>|title| - | 页面的总标题 |<br>|author| - | 作者信息（需详细配置）|<br>|theme| jdan/cleaver-retro | 采用主题样式 |<br>|output| basic.html | 生成的文件 |<br>|controls| true | 是否显示控制按钮 |</p>
<p>–</p>
<h2 id="生成PPT效果的HTML"><a href="#生成PPT效果的HTML" class="headerlink" title="生成PPT效果的HTML"></a>生成PPT效果的HTML</h2><p>安装完 cleaver 之后，我们可以来使用它<br>在终端里面执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cleaver [你的markdown文件]</div></pre></td></tr></table></figure>
<p>你就会得到你生成的 html 文件了</p>
<p>–</p>
<h2 id="主题样式"><a href="#主题样式" class="headerlink" title="主题样式"></a>主题样式</h2><p>Cleaver 有<a href="https://github.com/jdan/cleaver/wiki/Theme-Inde://github.com/jdan/cleaver/wiki/Theme-Index" target="_blank" rel="external">很多主题</a>可供选择：</p>
<ul>
<li>jdan/cleaver-retro</li>
<li>iamstarkov/cleaver-ribbon</li>
<li>sudodoki/reveal-cleaver-theme</li>
<li>sjaakvandenberg/cleaver-dark</li>
<li>sjaakvandenberg/cleaver-light</li>
<li>select/cleaver-select-theme</li>
</ul>
<p>个人推荐最后一个</p>
<p>–</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>幻灯片最后一页是自动生成的，会展示作者介绍</p>
<p>Cleaver 仍然还有一点排版上的问题，当然你可以贡献源码</p>
<p>总而言之，如果你需要进行不是一项特别复杂的汇报展示时，我们可以使用 Cleaver 代替 PowerPoint </p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本片博客为大家带来&lt;code&gt;Cleaver.js&lt;/code&gt;的指南&lt;/p&gt;
&lt;p&gt;幻灯片版本的介绍&lt;a href=&quot;https://lumpychen.github.io/cleaver_intro/&quot;&gt;点这里浏览&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="tool" scheme="http://lumpychen.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>Javascript异步探讨</title>
    <link href="http://lumpychen.github.io/2016/zh-cn/Javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://lumpychen.github.io/2016/zh-cn/Javascript异步编程/</id>
    <published>2016-10-17T10:17:02.000Z</published>
    <updated>2016-10-21T13:13:05.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p>在<code>GUI</code>编程中，用单一线程进行<code>GUI</code>控制是通常的做法</p>
<p>如果使用多线程来进行<code>GUI</code>编程，例如，一个线程修改某个<code>UI</code>模块的属性，另一个线程直接删除这个<code>UI</code>模块，那么<code>UI</code>的表现将很难被预测</p>
<p><code>Javascript</code>运行的环境是<code>单线程</code>的：每一个<code>window</code>或者一个<code>node.js</code>程序只有一个线程</p>
<p>因此，在<code>JS</code>程序正在执行的某个时间，只有特定的某个语句正在执行（此时其它的语句会被阻塞）</p>
<p>我个人很喜欢知乎上面<a href="https://www.zhihu.com/question/31982417/answer/54136684" target="_blank" rel="external">@云澹的回答</a></p>
<blockquote><p>运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。而浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。javascript引擎是单线程处理它的任务队列。所以当多个事件触发时，会依次放入队列，然后一个一个响应。</p>
<footer><strong>@云澹</strong></footer></blockquote>
<a id="more"></a>
<h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>在<code>Javascript</code>的主线程中，我们有一个<code>堆(heap)</code>和<code>栈(stack)</code>的结构：</p>
<p><img src="http://image.slidesharecdn.com/sonlejs-event-loop-160805060652/95/javascript-event-loop-11-638.jpg?cb=1470377352" alt="heap&amp;stack"></p>
<p>其中：</p>
<ul>
<li>堆的结构负责内存的分配</li>
<li>栈的结构负责线程中要执行的内容，被称为<code>访问栈(call stack)</code></li>
</ul>
<p>我们可以看看<code>访问栈</code>的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a*<span class="number">2</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> foo(b)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printDouble</span>(<span class="params">c</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> sum = bar(c)</div><div class="line">  <span class="built_in">console</span>.log(sum)</div><div class="line">&#125;</div><div class="line">printDouble(<span class="number">100</span>)</div></pre></td></tr></table></figure>
<p>在执行的过程中，我们的<code>访问栈</code>发生以下的变化：</p>
<ol>
<li>主线程进栈</li>
<li><code>printDouble</code>进栈</li>
<li><code>bar</code>进栈</li>
<li><code>foo</code>进栈</li>
<li><code>foo</code>出栈</li>
<li><code>bar</code>出栈</li>
<li><code>console.log</code>进栈</li>
<li><code>console.log</code>出栈</li>
<li><code>printDouble</code>出栈</li>
<li>主线程出栈</li>
</ol>
<p>如果我们在<code>foo</code>函数中发生了错误，我们会得到报错信息：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Uncaught <span class="string">Error:</span> 发生了错误(…)  <span class="string">VM1436:</span><span class="number">1</span></div><div class="line">  foo @ <span class="string">VM14136:</span><span class="number">1</span></div><div class="line">  bar @ <span class="string">VM14205:</span><span class="number">1</span></div><div class="line">  printDouble @ <span class="string">VM14298:</span><span class="number">1</span></div><div class="line">  (anonymous function) @ <span class="string">VM14324:</span><span class="number">1</span></div></pre></td></tr></table></figure>
<p>我们得到从上到下的结果就是所谓的<code>访问栈</code></p>
<p>当我们得到了<code>RangeError: maximum call stack size exceeded</code>的报错信息时，就代表我们的访问栈的大小不够了，去检查你的程序中有没有进行无限循环调用的语句吧 : )</p>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>因为<code>Javascript</code>是单线程，一个<code>Javascript</code>程序只有一个<code>访问栈</code>，函数语句按照进入的顺序一个接一个地被执行，前一个结束，才轮到后一个开始</p>
<p>然而有的时候，某些函数语句的主要时间消耗并不在<code>CPU</code>上，而是在输入输出设备（包括网络）上面，比如<code>Ajax</code>，这样的任务消耗了很多时间，从而阻塞了后续任务的执行，同时也浪费了<code>CPU</code>的资源</p>
<p>单线程任务同步执行的优势就是清晰易于理解，其缺陷就是经常会出现这种情况</p>
<p>为了解决这个问题，我们把要执行的任务分为两种：<code>同步(synchronous)</code>和<code>异步(asynchronous)</code></p>
<ul>
<li><code>同步任务</code>就是一般情况下的语句 —— 只有执行完毕之后才会执行后面的语句</li>
<li><code>异步任务</code>则是特殊的语句 —— 先执行特定的语句引发异步操作：调用相关接口，然后等待其他的部分的运转，等时机成熟再执行与运转结果相关的事件</li>
</ul>
<p>比如我们比较一下采用同步和异步的方式来执行<code>Ajax</code>：</p>
<ul>
<li>同步执行时，我们调用<code>Ajax</code>的接口，根据地址发起请求，直到响应返回，才执行接下来的任务</li>
<li>异步执行时，我们调用<code>Ajax</code>的接口请求相应地址，然后执行接下来的任务，当响应返回时，特定的函数语句会被加入到<code>访问栈</code></li>
</ul>
<p>更加明显的例子当我们使用<code>node.js</code>时，我们会发现很多函数会有同步异步两个版本，比如<code>readFile</code>和<code>readFileSync</code></p>
<ul>
<li>当你使用<code>readFile</code>时，最后一个参数为<code>回调函数</code>，响应返回时会被异步执行</li>
<li>当你使用<code>readFileSync</code>时，下一个语句一定是在<code>readFileSync</code>的文件操作结束返回结果后进行的</li>
</ul>
<h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>以下几类任务被当做异步任务：</p>
<ul>
<li><code>DOM</code>事件监听</li>
<li><code>XMLHttpRequest</code></li>
<li><code>setTimeout</code> &amp; <code>setInterval</code></li>
</ul>
<p>注意，<code>DOM</code>事件监听 – <code>addEventListener</code>函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数，事件触发时，表示异步任务完成，会将事件监听器函数封装成一个任务放到<code>任务队列</code>中，等待主线程执行，事件冒泡时，多条任务按照事件冒泡的顺序进入<code>任务队列</code></p>
<p>而<code>onclick</code>,<code>onchange</code>等的<code>handler</code>函数也是异步执行的，同理</p>
<p>异步任务伴随着<code>回调函数</code> —— 在任务时机成熟时执行的函数，<code>回调函数</code>是异步调用，也就是所谓事件驱动的</p>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p><code>Javascript</code>线程中有一个<code>任务队列</code>：保存着等待执行的异步任务的队列</p>
<p>观察一下所谓的<code>事件队列的模型</code>：</p>
<p><img src="http://images.cnitblog.com/blog2015/221923/201503/171756342043920.png" alt="模型"></p>
<p>我们举个关于<code>setTimeout</code>的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Timeout!'</span>)</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'end!'</span>)</div></pre></td></tr></table></figure>
<ol>
<li>主线程进栈</li>
<li><code>setTimeout</code>进栈</li>
<li>调用<code>setTimeout</code>的<code>API</code>，设置一个定时器，5秒钟之后<code>回调函数</code>加入<code>任务队列</code></li>
<li><code>setTimeout</code>出栈</li>
<li><code>console.log(&#39;end!&#39;)</code>进栈</li>
<li><code>console.log(&#39;end!&#39;)</code>出栈</li>
<li>主线程出栈</li>
<li>事件轮询，任务队列中的匿名函数进栈</li>
<li><code>console.log(&#39;Timeout!&#39;)</code>进栈</li>
<li><code>console.log(&#39;Timeout!&#39;)</code>出栈</li>
<li>匿名函数出栈</li>
</ol>
<p>每当<code>访问栈</code>空的时候，栈会执行<code>事件轮询</code>操作，从<code>任务队列</code>里面读取任务并执行</p>
<p>所以，异步过程的<code>回调函数</code>，一定不在当前这一轮事件循环中执行</p>
<h2 id="单线程和异步"><a href="#单线程和异步" class="headerlink" title="单线程和异步"></a>单线程和异步</h2><p>所以像<code>setTimeout</code>这样的异步任务不一定会准确执行</p>
<p>我们先看一下回答中的代码段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"first"</span>)</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'second'</span>)</div><div class="line">  &#125;,<span class="number">5</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</div><div class="line">  foo()</div><div class="line">&#125;</div><div class="line"><span class="comment">// 执行结果为：first*1000000, second*1000000</span></div></pre></td></tr></table></figure>
<p>按照我们正常的思维，我们执行1000000次<code>foo</code>函数，每执行一次都会设置一个五毫秒的定时器，然后<code>console.log</code>出<code>&quot;second&quot;</code>，但是我们发现控制台在几秒内一直在重复弹出<code>&quot;first&quot;</code>（这段时间远大于五毫秒），并没有<code>second</code>在这段时间弹出，直到所有<code>first</code>全部弹出完毕</p>
<p>现在我们能理解这个问题了，只有<code>访问栈</code>里面的任务全部推出之后，<code>任务队列</code>里面的<code>回调函数</code>才会开始执行，所以在<code>first</code>没有完成输出之前，异步调用的<code>second</code>不会执行</p>
<p>我们同时可以理解<code>foo()</code>和<code>setTimeout(foo,0)</code>的具体区别了</p>
<h2 id="在React出现的一点点问题"><a href="#在React出现的一点点问题" class="headerlink" title="在React出现的一点点问题"></a>在React出现的一点点问题</h2><p>在<code>React</code>中，<code>setState</code>函数是异步执行的，如果你在<code>Component</code>的方法里面先调用<code>setState</code>再调用<code>this.state</code>，你会发现后面<code>this.state</code>得到的值与前面<code>setState</code>设置的值不一样，得到的仍然是<code>setState</code>之前的值</p>
<p>看完前面的分析，我想这并不那么难以理解了：<code>setState</code>会进入<code>任务队列</code>，直到<code>访问栈</code>被清空，才会执行<code>事件轮询</code>，从而执行<code>任务队列</code>中的任务</p>
<p>我在<code>React</code>的开发中遇到过如下的问题：</p>
<p><a href="http://stackoverflow.com/questions/28922275/in-reactjs-why-does-setstate-behave-differently-when-called-synchronously" target="_blank" rel="external">这个问题</a>讲述了同步/异步调用<code>setState</code>的区别</p>
<p><a href="http://jsbin.com/dawezapoga/edit?js,console,output" target="_blank" rel="external">这个jsbin</a>上面存在相关的实例：</p>
<p><code>Setting value</code>代表<code>render</code>时<code>State</code>里面的内容<br><code>Current value</code>代表<code>render</code>时，用<code>getDOMNode</code>得到的<code>DOM</code>里面的属性</p>
<div class="tip"><br>注意：这是一个<a href="https://facebook.github.io/react/docs/forms.html#controlled-components" target="_blank" rel="external">Controlled Components</a>，会忽视用户对<code>input.value</code>在<code>DOM</code>上的改变，但<code>e.target.value</code>的值是用户在<code>input</code>上改变后的值<br></div>

<p>我把 @FakeRainBrigand 的答案 以及自己的理解，进行了结合，得到了下面的过程</p>
<p>同步调用：</p>
<ol>
<li>输入<code>X</code>到<code>input</code>标签里面</li>
<li><code>input.value</code>不变，触发<code>onchange</code>事件</li>
<li>执行事件处理函数<code>onchange</code></li>
<li>执行<code>setState({value: &#39;HelXlo&#39;})</code></li>
<li>进行虚拟<code>DOM</code>的<code>Diff</code>操作，识别出<code>input.value</code>应该是<code>&#39;HelXlo&#39;</code>，将<code>DOM</code>操作加入<code>任务队列</code></li>
<li><code>onchange</code>任务结束，将<code>render</code>加入<code>任务队列</code></li>
<li>执行<code>事件轮询</code>，依次执行<code>DOM</code>操作与<code>render</code><ul>
<li><code>DOM</code>操作将<code>input.value</code>改为当前<code>state</code>的值<code>为&#39;HelXlo&#39;</code></li>
<li><code>render</code>，此时<code>state</code>里面<code>value</code>和<code>DOM</code>里面<code>input.value</code>都是<code>&#39;HelXlo&#39;</code></li>
</ul>
</li>
</ol>
<p>异步调用：</p>
<ol>
<li>输入<code>X</code>到<code>input</code>标签里面</li>
<li><code>input.value</code>不变，触发<code>onchange</code>事件</li>
<li>执行事件处理函数<code>onchange</code>，将<code>setState</code>的定时器加入<code>任务队列</code></li>
<li><code>onchange</code>任务结束，将<code>render</code>加入<code>任务队列</code></li>
<li>进行<code>事件轮询</code>，执行了<code>任务队列</code>中的定时器，执行<code>setState</code></li>
<li>执行<code>setState({value: &#39;HelXlo&#39;})</code></li>
<li>进行虚拟<code>DOM</code>的<code>Diff</code>操作，识别出<code>input.value</code>应该是’Hello’<code>，将</code>DOM<code>操作加入</code>任务队列`</li>
<li><code>render</code>，此时<code>state</code>里面<code>value</code>为<code>&#39;HelXlo&#39;</code>，但<code>DOM</code>上<code>input.value</code>为<code>&#39;Hello&#39;</code></li>
<li>执行<code>任务队列</code>后面的任务，进行DOM操作，改变<code>input.value</code>为<code>&#39;HelXlo&#39;</code>（此时<code>DOM</code>更新令光标被置于<code>input</code>末尾）</li>
</ol>
<div class="tip"><br>有一点小小的 <strong>魔法</strong>： <code>React</code>会在<code>onchange</code>这种<code>事件处理函数</code>后异步调用<code>render</code>方法（而<code>DOM</code>操作也是异步执行的，别忘了）<br></div>

<p>通过各种猜想和实验，我得到了上面的结果</p>
<p>我不确认自己的想法是对的，所以这篇博客先放在这里，等我对源码有了更深的理解在回来证实和修改</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;GUI&lt;/code&gt;编程中，用单一线程进行&lt;code&gt;GUI&lt;/code&gt;控制是通常的做法&lt;/p&gt;
&lt;p&gt;如果使用多线程来进行&lt;code&gt;GUI&lt;/code&gt;编程，例如，一个线程修改某个&lt;code&gt;UI&lt;/code&gt;模块的属性，另一个线程直接删除这个&lt;code&gt;UI&lt;/code&gt;模块，那么&lt;code&gt;UI&lt;/code&gt;的表现将很难被预测&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Javascript&lt;/code&gt;运行的环境是&lt;code&gt;单线程&lt;/code&gt;的：每一个&lt;code&gt;window&lt;/code&gt;或者一个&lt;code&gt;node.js&lt;/code&gt;程序只有一个线程&lt;/p&gt;
&lt;p&gt;因此，在&lt;code&gt;JS&lt;/code&gt;程序正在执行的某个时间，只有特定的某个语句正在执行（此时其它的语句会被阻塞）&lt;/p&gt;
&lt;p&gt;我个人很喜欢知乎上面&lt;a href=&quot;https://www.zhihu.com/question/31982417/answer/54136684&quot;&gt;@云澹的回答&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。而浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。javascript引擎是单线程处理它的任务队列。所以当多个事件触发时，会依次放入队列，然后一个一个响应。&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;@云澹&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://lumpychen.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Econometrics - OLS</title>
    <link href="http://lumpychen.github.io/2016/en/Econometrics-OLS/"/>
    <id>http://lumpychen.github.io/2016/en/Econometrics-OLS/</id>
    <published>2016-10-06T05:53:33.000Z</published>
    <updated>2016-10-15T08:27:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p>This article contains notes of chapter 2 – Ordinary Least Squares.</p>
<p>In the first place, we build an agreement that the purpose of regression analysis is to take a purely theoretical equation:</p>
<p>$$ Y_i=\beta_0+\beta_1X_i+\varepsilon_i $$</p>
<p>and use a set of data to create an estimated equation:</p>
<p>$$ \hat{Y_i}=\hat{\beta_0}+\hat{\beta_1}X_i $$</p>
<p>\(\hat{Y_i}\) is the same as \(E(Y|X)\)</p>
<p>Then, the emphasis of this chapter is on understanding what OLS attempts to do and how it goes about doing it.</p>
<a id="more"></a>
<h2 id="OLS"><a href="#OLS" class="headerlink" title="OLS"></a>OLS</h2><p>Ordinary Least Squares calcutes the \(\hat{\beta}\) so as to minimize the sum of the squared residuals:</p>
<p>$$ OLS_{min} \sum_{i=1}^N e_i^2 (i=1,2,…,N) $$</p>
<p>We can claim that Ordinary Least Square minimizes the value of \(\sum(Y_i-\hat{Y_i})\)</p>
<p>Why we use OLS?</p>
<ul>
<li>OLS is relative easy to use.</li>
<li>The goal of minimizing \(e^2\) is appropriate from theory.</li>
<li>OLS estimates have a number of useful characteristics.</li>
</ul>
<h2 id="How-OLS-works"><a href="#How-OLS-works" class="headerlink" title="How OLS works"></a>How OLS works</h2><p>In a Single-Independent-Variable regression model:</p>
<p>$$ Y_i = \beta_0 + \beta_1 X_i + \varepsilon_i $$</p>
<p>We know that:</p>
<p>$$ \sum e^2 = \sum (Y_i - \hat{\beta_0} -\hat{\beta_1}X_i)^2 $$</p>
<p>From an equation with just one independent variable, these coefficients are:</p>
<p>$$ \hat{\beta_1} = \frac{\sum_{i=1}^N[(X_i - X)(Y_i - Y)]}{\sum_{i=1}{N}(X_i - X)^2} $$</p>
<p>$$ \hat{\beta_0} = Y - \hat{\beta_1}X $$</p>
<p>In a mutivariate regression model, we also get the estimated coefficients expression, but it’s quite complicated, we prefer a computer’s calculation.</p>
<p>But we should learn that the key is:</p>
<blockquote><p>“Specifically, a multivariate coefficient indicates the change in the dependent variable associate with a one-unit increase in the independent variable in question <code>holding constant the other independent variables in the equation</code>.”</p>
<footer><strong>A.H.Studenmund</strong><cite>-- Using Econometrics: A Pratical Guide</cite></footer></blockquote>
<h2 id="Sum-of-Squares"><a href="#Sum-of-Squares" class="headerlink" title="Sum of Squares"></a>Sum of Squares</h2><p>To get a measure of the amount of variation to be explained by the regression, we use the squared variations, which called the total sum of squares.</p>
<p>The Total Sum of Squares:</p>
<p>$$ TSS = \sum_{i=1}^N(Y_i-Y)^2 $$</p>
<p>The total sum of squares has two components:</p>
<ul>
<li>variation which can be explained by the regression – the explained sum of squares</li>
<li>variation which can’t be explained by the regression – the residual sum of squares</li>
</ul>
<p>The explained sum of squares:</p>
<p>$$ ESS = \sum_{i=1}^N(\hat{Y_i}-Y)^2 $$</p>
<p>The residual sum of squares:</p>
<p>$$ RSS = \sum_{i=1}^N(Y_i-\hat{Y_i}) $$</p>
<p>The decomposition of variance:</p>
<p>$$ TSS = ESS+ RSS $$</p>
<h2 id="Describing-the-fit-of-a-estimated-model"><a href="#Describing-the-fit-of-a-estimated-model" class="headerlink" title="Describing the fit of a estimated model"></a>Describing the fit of a estimated model</h2><p>The simplest commonly used measure of fit is the coefficient of determination, \(R^2\), which equals to:</p>
<p>$$ R^2 = \frac{ESS}{TSS} = 1 - \frac{RSS}{TSS}, and 0&lt;=R^1&lt;=1 $$</p>
<p>The higher \(R^2\) is, the closer the estimated regression equation fits it sample data.</p>
<blockquote><p>“Since OLS selects the parameter estimates that minimize RSS, OLS provides the largest possible \(R^2\), given a linear model.”</p>
<footer><strong>A.H.Studenmund</strong><cite>-- Using Econometrics: A Pratical Guide</cite></footer></blockquote>
<h2 id="Adjust-R-2"><a href="#Adjust-R-2" class="headerlink" title="Adjust \(R^2\)"></a>Adjust \(R^2\)</h2><p>If we add another independent variable to a particular equation, we will find the equation with the greater number of independent variables will always have a better (or equal) fit, and \(R^2\) won’t decrease.</p>
<p>In essence, \(R^2\)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This article contains notes of chapter 2 – Ordinary Least Squares.&lt;/p&gt;
&lt;p&gt;In the first place, we build an agreement that the purpose of regression analysis is to take a purely theoretical equation:&lt;/p&gt;
&lt;p&gt;$$ Y_i=\beta_0+\beta_1X_i+\varepsilon_i $$&lt;/p&gt;
&lt;p&gt;and use a set of data to create an estimated equation:&lt;/p&gt;
&lt;p&gt;$$ \hat{Y_i}=\hat{\beta_0}+\hat{\beta_1}X_i $$&lt;/p&gt;
&lt;p&gt;\(\hat{Y_i}\) is the same as \(E(Y|X)\)&lt;/p&gt;
&lt;p&gt;Then, the emphasis of this chapter is on understanding what OLS attempts to do and how it goes about doing it.&lt;/p&gt;
    
    </summary>
    
    
      <category term="course" scheme="http://lumpychen.github.io/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>JS正则表达式快速入门</title>
    <link href="http://lumpychen.github.io/2016/zh-cn/Javascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://lumpychen.github.io/2016/zh-cn/Javascript正则表达式快速入门/</id>
    <published>2016-09-26T02:26:09.000Z</published>
    <updated>2016-10-15T08:27:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p>我们都爱正则表达式，但是一个个奇怪字符的组合总是让我这种弱鸡感到难以领悟。</p>
<p>每次看到一个正则匹配式却理解不了，我都安慰自己：“反正我已经知道它是用来匹配文本的”</p>
<p>为什么不现在直接把它学会呢？</p>
<a id="more"></a>
<hr>
<p>首先推一个可以帮助你理解正则的网站<a href="https://regexper.com" target="_blank" rel="external">正则表达式可视化</a></p>
<p>还有一个 Atom 插件 <a href="https://atom.io/packages/regex-railroad-diagram" target="_blank" rel="external">regex-railroad-diagram</a></p>
<p>这样的可视化模型可以帮助你快速回忆与熟悉正则字符的含义。</p>
<h2 id="1-字符"><a href="#1-字符" class="headerlink" title="1.字符"></a>1.字符</h2><p>正则表达式中我们可以使用两种字符：</p>
<ul>
<li>原义字符：原义文本字符代表字符本身的匹配</li>
<li>元字符：元字符是正则表达式中有特殊含义的字符，其组合代表特殊字符或者其他逻辑</li>
</ul>
<p>在正则表达式中以下字符有特殊含义，为元字符<br>所以只有转义之后它们才能作为原义文本字符来使用：</p>
<p><code>*</code>, <code>+</code>, <code>?</code>, <code>$</code>, <code>^</code>, <code>.</code>, <code>|</code>, <code>\</code>, <code>()</code>, <code>[]</code>, <code>{}</code></p>
<p>比如你想要匹配字符串中出现的<code>$</code>, 必须在正则表达式中使用<code>\$</code>进行转义</p>
<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>这几个组合而成的元字符组合会匹配相应特殊字符：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">匹配特殊字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\t</code></td>
<td style="text-align:center">制表符</td>
</tr>
<tr>
<td style="text-align:center"><code>\v</code></td>
<td style="text-align:center">垂直制表符</td>
</tr>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td style="text-align:center">换行符</td>
</tr>
<tr>
<td style="text-align:center"><code>\r</code></td>
<td style="text-align:center">回车</td>
</tr>
<tr>
<td style="text-align:center"><code>\f</code></td>
<td style="text-align:center">换页</td>
</tr>
<tr>
<td style="text-align:center"><code>c*</code></td>
<td style="text-align:center">Ctrl+特定字符</td>
</tr>
</tbody>
</table>
<h2 id="2-字符匹配方式"><a href="#2-字符匹配方式" class="headerlink" title="2.字符匹配方式"></a>2.字符匹配方式</h2><h4 id="正常匹配："><a href="#正常匹配：" class="headerlink" title="正常匹配："></a>正常匹配：</h4><p>在正则表达式中使用原义字符或组合成的特殊字符会正常匹配相应字符</p>
<p>在正则表达式中使用<code>a</code>会匹配文本<code>a1b2ab3</code>中第一个字符<code>a</code>和倒数第三个字符<code>a</code></p>
<h4 id="字段匹配："><a href="#字段匹配：" class="headerlink" title="字段匹配："></a>字段匹配：</h4><p>在正则表达式中使用连续的原义字符或组合而成的特殊字符会匹配相应字符组合</p>
<p>在正则表达式中使用<code>ab</code>会匹配文本<code>a1b2ab3</code>中倒数第二三个字符<code>ab</code></p>
<h4 id="类匹配："><a href="#类匹配：" class="headerlink" title="类匹配："></a>类匹配：</h4><p>在正则表达式中使用元字符：</p>
<p><code>[ ]</code>: 创建<em>类</em>将匹配<code>[ ]</code>中的任意字符</p>
<p>类中字符的连写代表<em>或</em>的关系——满足连写的字符其中一者就将会被匹配</p>
<p>正则表达式中使用<code>[ab]</code>会匹配文本<code>a1b2ab3</code>中所有的<code>a</code>与<code>b</code>字符</p>
<p>特殊的<em>类</em>：</p>
<ul>
<li><code>[^]</code>: 反相匹配——匹配不是<code>[^</code>和<code>]</code>中的任意字符</li>
<li><code>[a-z]</code>: 小写字母匹配——从<code>a</code>到<code>z</code>的小写英文字符</li>
<li><code>[A-Z]</code>: 大写字母匹配——从<code>A</code>到<code>Z</code>的大写英文字符</li>
<li><code>[0-9]</code>: 数字匹配——从<code>0</code>到<code>9</code>的数字字符</li>
</ul>
<p>同时有一些等价的元字符方便使用：</p>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">等价类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">[^\r\n]</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:center">[0-9]</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:center">[^0-9]</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:center">[\t\n\v\f\r]</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td style="text-align:center">[^\t\n\v\f\r]</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:center">[a-zA-Z_0-9]</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:center">[^a-zA-Z_0-9]</td>
</tr>
</tbody>
</table>
<p>具体什么含义？根据之前的线索推断一下吧 : )</p>
<h4 id="量匹配"><a href="#量匹配" class="headerlink" title="量匹配"></a>量匹配</h4><p>有的时候，正则表达式需要对字符出现次数进行匹配，此时我们需要使用量匹配的元字符</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center">最多出现一次</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">至少出现一次</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">出现任意次</td>
</tr>
<tr>
<td style="text-align:center"><code>{n}</code></td>
<td style="text-align:center">出现n次</td>
</tr>
<tr>
<td style="text-align:center"><code>{n,m}</code></td>
<td style="text-align:center">出现n到m次</td>
</tr>
<tr>
<td style="text-align:center"><code>{n,}</code></td>
<td style="text-align:center">至少出现n次</td>
</tr>
</tbody>
</table>
<p>还包含其它的逻辑匹配</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>x(?=y)</code></td>
<td style="text-align:center">只有当<code>x</code>后面紧跟着<code>y</code>时，才匹配<code>x</code></td>
</tr>
<tr>
<td style="text-align:center"><code>x(?!y)</code></td>
<td style="text-align:center">只有当<code>x</code>后面不是紧跟着<code>y</code>时，才匹配<code>x</code></td>
</tr>
<tr>
<td style="text-align:center">`x</td>
<td style="text-align:center">y`</td>
<td>匹配<code>x</code>或<code>y</code></td>
</tr>
</tbody>
</table>
<p>量匹配的元字符跟随在字符的后面生效，比如：</p>
<p><code>T\d?</code>匹配后面最多出现一次数字字符的字符<code>T</code></p>
<div class="tip"><br>进行<code>{n,m}</code>的匹配时，会出现重复满足匹配条件的情况，<br>用正则表达式<code>a\d{2,4}</code>对字符串<code>a123456</code>进行匹配，<br>会匹配到<code>a12</code>,<code>a123</code>,<code>a1234</code>中的哪个呢？<br></div>

<p>默认情况下，正则表达式处于贪婪模式，即尽可能多地匹配字符串，因此匹配结果应该是<code>a1234</code></p>
<p>如果想进入非贪婪模式，需要在量词后面加一个问号：<code>a\d{2,4}?</code>，此时正则表达式一旦匹配成功就不会继续匹配</p>
<p>此时匹配结果为<code>a12</code></p>
<h4 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h4><p>在正则表达式中使用<code>()</code>可以在正则表达式中生成“组”</p>
<p>“组”在字符组合的时候具有相对的优先级：</p>
<p>当我们的正则表达式复杂的时候，我们需要分组进行元字符和字符的组合：</p>
<p>比如我们使用<code>[a-z]\d{3}</code>匹配<code>a1b2c3d4</code>就是无效的，因为量匹配仅对其前面的字符有效，这个正则表达式的意思就是匹配一个后面跟随三个数字的字母</p>
<p>当我们想要匹配另一种含义——“连续出现三次字母+数字时”，我们就需要采用分组匹配的方式：</p>
<p>使用正则表达式<code>([a-z]\d){3}</code>匹配<code>a1b2c3d4</code>就会得到<code>a1b2c3</code></p>
<p>同时我们可以使用分组匹配来配合逻辑元字符进行不同逻辑的匹配效果，比如：</p>
<p>使用正则表达式<code>Hel(lo|en)</code>对字符串<code>Hello Helen!</code>进行匹配，匹配得到的结果为</p>
<p><code>Hello</code>和<code>Helen</code></p>
<p>“组”除了优先级的提升，还有其他的特殊效果：</p>
<p>分组匹配可以在替换的时候配合<code>$</code>进行反向引用，反向引用会在后面的章节进行讲解</p>
<p>同时也可以通过<code>exec</code>方法被分拣到数组里面（见后面章节）</p>
<div class="tips"><br>如果我们仅仅想使用括号操作元字符效果的范围，并不想生产分组匹配的“组”并实现相关特殊效果，我们可以使用<code>(?:</code>+内容+<code>)</code>的括号来达成目的<br></div>

<h4 id="边界匹配"><a href="#边界匹配" class="headerlink" title="边界匹配"></a>边界匹配</h4><p>边界匹配是采用元字符的一种特殊匹配方式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">匹配行首的边界</td>
</tr>
<tr>
<td style="text-align:center"><code>$</code></td>
<td style="text-align:center">匹配行末的边界</td>
</tr>
<tr>
<td style="text-align:center"><code>\b</code></td>
<td style="text-align:center">匹配单词边界</td>
</tr>
<tr>
<td style="text-align:center"><code>\B</code></td>
<td style="text-align:center">匹配非单词边界</td>
</tr>
</tbody>
</table>
<p>这些字符本身并不匹配字符，匹配的是特定的边界</p>
<p>在字符串<code>There HiThere There</code>中使用（全局模式）</p>
<ul>
<li>正则表达式<code>^</code>/<code>$</code>结果替换为<code>#</code> —— <code>#There HiThere There</code> 与 <code>There HiThere There#</code></li>
<li>正则表达式<code>^T</code>/<code>e$</code>结果替换为<code>#</code> —— <code>#here HiThere There</code> 与 <code>There HiThere Ther#</code></li>
<li>正则表达式<code>\b</code>结果替换为<code>#</code> —— <code>#There# #HiThere# #There#</code></li>
<li>正则表达式<code>\bT</code>结果替换为<code>#</code> —— <code>#here HiThere #here</code></li>
<li>正则表达式<code>\bThere\b</code> —— 匹配第一个单词<code>There</code>与最后一个单词<code>There</code></li>
<li>正则表达式<code>\BThere\b</code> —— 匹配<code>HiThere</code>里面的<code>There</code></li>
</ul>
<p>根据这些规律的提示，加上你自己的练习，掌握边界匹配不需要太多时间。</p>
<div class="tip"><br>  正则表达式默认会将一段文本中每个换行处转化为<code>\n</code>换行符，而这不会被<code>^</code>和<code>$</code>匹配，除非开启了多行模式。有关多行模式的内容，见下一章节。<br></div>

<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>修饰符是针对于每个正则表达式设置的属性（它们之间互相不冲突）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>g</code></td>
<td style="text-align:center">全局模式：对字符串从头开始不止一次地进行匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>i</code></td>
<td style="text-align:center">忽略大小写模式：忽略英文字母大小写</td>
</tr>
<tr>
<td style="text-align:center"><code>m</code></td>
<td style="text-align:center">多行模式：令元字符<code>^</code>和<code>$</code>在多行模式下进行工作（行是由<code>\n</code>或<code>\r</code>分割的）</td>
</tr>
<tr>
<td style="text-align:center"><code>y</code></td>
<td style="text-align:center">黏性模式：只从<code>lastIndex</code>位置开始匹配（且不试图从任何之后的索引匹配）</td>
</tr>
</tbody>
</table>
<div class="tip"><br><code>Javascript</code>全局模式下重复匹配会有一些奇怪的事情发生（比如下面这段代码）这是因为<code>lastIndex</code>属性在全局模式下生效，其具体特性见后面的章节<br></div>

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/\w/g</span></div><div class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/\w/</span></div><div class="line">reg.test(<span class="string">'a'</span>)</div><div class="line"><span class="comment">//true</span></div><div class="line">reg.test(<span class="string">'a'</span>)</div><div class="line"><span class="comment">//false</span></div><div class="line">reg1.test(<span class="string">'a'</span>)</div><div class="line"><span class="comment">//true</span></div><div class="line">reg1.test(<span class="string">'a'</span>)</div><div class="line"><span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>而且，前文说过，我们之前的实例全部在默认使用全局模式，如果不在全局模式之下，正则表达式只会匹配字符串从头开始的第一个字符段</p>
<h2 id="2-JavaScript-中的-RegExp-对象"><a href="#2-JavaScript-中的-RegExp-对象" class="headerlink" title="2.JavaScript 中的 RegExp 对象"></a>2.JavaScript 中的 RegExp 对象</h2><p>在<code>JavaScript</code>中，由<code>/</code>开始，由<code>/</code>结束（或者跟随有效正则修饰符）的字段会被<code>JavaScript</code>编译器正确解析为一个<code>RegExp</code>对象。</p>
<p>同时<code>//</code> —— 空的正则表达式会被解析为注释</p>
<p><code>RegExp</code>是<code>JavaScript</code>中的内置对象，其构造函数创建了一个正则表达式对象，用来匹配文本</p>
<p><code>RegExp</code>的详细特性在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="external">mdn</a>上有详细讲解与实例</p>
<p><code>RegExp</code>有两种构造方式：</p>
<ul>
<li>字面量方式</li>
<li>构造函数方式</li>
</ul>
<h4 id="字面量方式"><a href="#字面量方式" class="headerlink" title="字面量方式"></a>字面量方式</h4><blockquote>
<p><code>RegExp</code>对象的实例由<code>/</code>+正则表达式正文+<code>/</code>+正则表达式修饰符组成</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/\bis\b/g</span></div></pre></td></tr></table></figure>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\bis\\b'</span>, <span class="string">'g'</span>)</div></pre></td></tr></table></figure>
<p><code>RegExp</code>构造函数接受两个参数：</p>
<ul>
<li>包含正则表达式的一个字符串（注意在字符串中转义符需要转义输入）</li>
<li>包含正则表达式修饰符的一个字符串</li>
</ul>
<p>因此我们更倾向于使用字面量方式进行 <code>RegExp</code> 实例的构建</p>
<h4 id="RegExp对象的属性"><a href="#RegExp对象的属性" class="headerlink" title="RegExp对象的属性"></a>RegExp对象的属性</h4><p><code>JavaScript</code>中，<code>RegExp</code>有以下属性：</p>
<ul>
<li><code>RegExp.lastIndex</code></li>
<li><code>RegExp.prototype.global</code></li>
<li><code>RegExp.prototype.ignoreCase</code></li>
<li><code>RegExp.prototype.mutiline</code></li>
<li><code>RegExp.prototype.source</code></li>
<li><code>RegExp.prototype.sticky</code></li>
</ul>
<p>以上属性中，除了<code>lastIndex</code>和<code>source</code>以外，其它属性都描述着<code>RegExp</code>对象的在构造时附件的修饰模式 – 由构造<code>RegExp</code>时附加的修饰符决定（它们都是布尔值）</p>
<p><code>source</code>属性是<code>RegExp</code>对象正则表达式正文的字符串 —— 正则表达式<code>/</code>内部的内容</p>
<p><code>lastIndex</code>是个复杂的属性，它相当<code>RegExp</code>上的一个标记，它可写，指定着下一次匹配的起始索引位置，同时也是匹配的上一次结果尾部后一个字符的索引位置（只有在全局模式下该属性才有效）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/\w/</span></div><div class="line"><span class="keyword">while</span>(reg.test(<span class="string">'abc'</span>))&#123;</div><div class="line">  <span class="built_in">console</span>.log(reg.lastIndex)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>得到结果为<code>1</code>,<code>2</code>,<code>3</code></p>
<p>全局正则表达式的匹配可以配合<code>lastIndex</code>进行匹配异步的驱动</p>
<p>有很多与正则表达式有关的方法可以让我们更轻松地进行字符串操作：</p>
<h4 id="RegExp对象的方法"><a href="#RegExp对象的方法" class="headerlink" title="RegExp对象的方法"></a>RegExp对象的方法</h4><p><code>JavaScript</code>中，<code>RegExp</code>有以下方法：</p>
<ul>
<li><code>RegExp.prototype.exec()</code></li>
<li><code>RegExp.prototype.test()</code></li>
<li><code>RegExp.prototype.toString()</code></li>
</ul>
<p><code>exec</code>方法接受一个字符串作为参数，返回一个数组：</p>
<ul>
<li>第一个元素是正则表达式匹配到的文本</li>
<li>之后的元素都是依次排列的，正则表达式中从前到后每个分组匹配到的文本</li>
<li>数组中存在两个索引：<ul>
<li><code>index</code>: 匹配到字段开始的索引</li>
<li><code>input</code>: 匹配的整体字符串</li>
</ul>
</li>
<li>正则表达式匹配不到返回<code>null</code></li>
</ul>
<p>全局模式<code>RegExp</code>对象调用<code>exec</code>时，可以多次执行<code>exec</code>方法来查找同一个字符串中的其它的成功匹配，每次<code>exec</code>都会更新<code>lastIndex</code>属性</p>
<p><code>test</code>方法接受一个字符串作为参数，如果正则表达式可以匹配到字符串里的字段，返回<code>true</code>，否则返回<code>false</code></p>
<p><code>exec</code>方法和<code>test</code>方法在全局的<code>RegExp</code>对象执行时都会更新<code>lastIndex</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/\w\d/g</span>,</div><div class="line">  str = <span class="string">'a1b2c3d4'</span></div><div class="line"><span class="built_in">console</span>.log(reg.lastIndex) <span class="comment">//0</span></div><div class="line">reg.test(str) <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(reg.lastIndex) <span class="comment">//2</span></div><div class="line">reg.exec(str) <span class="comment">// [ 'b2', index: 2, input: 'a1b2c3d4'  ]</span></div><div class="line"><span class="built_in">console</span>.log(reg.lastIndex) <span class="comment">// 4</span></div></pre></td></tr></table></figure>
<p>这个表格是测试后的<code>lastIndex</code>变化规律：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>lastIndex</code>索引范围</th>
<th style="text-align:center">下一次匹配结果</th>
<th style="text-align:center">下一次匹配<code>lastIndex</code>的调整</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">大于字符串的长度</td>
<td style="text-align:center">一定失败</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">等于字符串的长度，<code>RegExp</code>不匹配空字符串</td>
<td style="text-align:center">一定失败</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">等于字符串的长度，<code>RegExp</code>匹配空字符串</td>
<td style="text-align:center">成功匹配到空字符串</td>
<td style="text-align:center">不变</td>
</tr>
<tr>
<td style="text-align:center">小于字符串的长度</td>
<td style="text-align:center">在索引位置向后进行匹配的结果</td>
<td style="text-align:center">下一次匹配到字段的后一位，匹配不到则归0</td>
</tr>
</tbody>
</table>
<p><code>toString</code>方法则返回是正则表达式的全文的字符串</p>
<h4 id="其他与RegExp对象相关的方法"><a href="#其他与RegExp对象相关的方法" class="headerlink" title="其他与RegExp对象相关的方法"></a>其他与RegExp对象相关的方法</h4><ul>
<li><code>String.prototype.match()</code></li>
<li><code>String.prototype.replace()</code></li>
<li><code>String.prototype.search()</code></li>
<li><code>String.prototype.split()</code></li>
</ul>
<p><code>match</code>与<code>RegExp</code>的<code>exec</code>方法相似，接受一个<code>RegExp</code>对象为参数，返回一个包含匹配结果的数组：</p>
<ul>
<li>在非全局模式下，返回的数组包含和<code>RegExp.exec</code>一样的内容</li>
<li>在全局模式下，返回包含所有匹配字段的数组</li>
<li>如果不能匹配到，则返回<code>null</code></li>
</ul>
<p><code>replace</code>方法接受两个参数：第一个参数是<code>RegExp</code>或字符串，第二个参数为字符串或函数，字符串调用<code>replace</code>之后会将字符串中第一个参数正则匹配到的/出现的替换为某个字符串，详细请看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="external">mdn</a></p>
<p>第二个参数作为字符串的话可以使用<code>$</code>号来进行反向引用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'2016-10-10'</span>.replace(<span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g</span>, <span class="string">'$2$3$1'</span>)</div><div class="line"><span class="comment">// 10102016</span></div><div class="line"><span class="string">'2016-10-10'</span>.replace(<span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g</span>, <span class="string">'\$2\$3\$1'</span>)</div></pre></td></tr></table></figure>
<p>除了分组匹配，还有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量名</th>
<th style="text-align:center">代表的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>$$</code></td>
<td style="text-align:center">插入个<code>$</code></td>
</tr>
<tr>
<td style="text-align:center"><code>$&amp;</code></td>
<td style="text-align:center">插入匹配的子串</td>
</tr>
<tr>
<td style="text-align:center">`$``</td>
<td style="text-align:center">插入当前匹配的子串左边的内容</td>
</tr>
<tr>
<td style="text-align:center"><code>$&#39;</code></td>
<td style="text-align:center">插入当前匹配的子串右边的内容</td>
</tr>
</tbody>
</table>
<p>第二个参数作为函数的话有这几个（至少三个以上）个参数：</p>
<ul>
<li>第<code>1</code>个参数：匹配到的文本字符串</li>
<li>第<code>2</code>到第<code>n</code>个参数：分组匹配到的内容（设进行了<code>n-1</code>次分组匹配）</li>
<li>第<code>n+1</code>个参数：匹配项在字符串中的<code>index</code></li>
<li>第<code>n+2</code>个参数：原字符串</li>
</ul>
<div class="tip"><br>  <code>replace</code>的第一个参数，我们如果提供字符串作为参数，就会被自动转化为<code>RegExp</code>对象 —— 不附带任何修饰模式，实例如下： </div>

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'a1a2a3a4'</span>.replace(<span class="string">'a'</span>,<span class="string">'b'</span>) <span class="comment">//b1a2a3a4</span></div><div class="line"><span class="string">'a1a2a3a4'</span>.replace(<span class="regexp">/a/g</span>,<span class="string">'b'</span>) <span class="comment">//b1b2b3b4</span></div></pre></td></tr></table></figure>
<p><code>search</code>方法与<code>RegExp</code>的<code>test</code>相似，<br>接受一个<code>RegExp</code>对象为参数，但是返回值为第一次匹配到字段的索引数值（如果没有匹配到则返回<code>-1</code>）</p>
<p><code>split</code>方法接受两个参数，第一个参数为分隔符（可以是字符串和<code>RegExp</code>），第二个参数为片段数量的限定值（可选），返回一个由一个个分隔符之间的字段组成的数组</p>
<p>如果不存在有效参数，则返回整个字符串在第一位的数组</p>
<p>如果分隔符是一个空字符串，则会把原字符串中每个字符的装在数组里返回</p>
<p>如果分隔符是包含分组匹配的正则表达式，则每次匹配到结果时，分组匹配到的结果也会插入到返回的数组中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/\*/</span>,</div><div class="line">  reg2 = <span class="regexp">/(\*)/</span>,</div><div class="line">  str = <span class="string">'c*x*y'</span></div><div class="line">str.split(reg1) <span class="comment">// ["c", "x", "y"]</span></div><div class="line">str.split(reg2) <span class="comment">// ["c", "*", "x", "*", "y"]</span></div></pre></td></tr></table></figure>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>写了这么多，笔者相信你们头都晕了 : )</p>
<p>记住正则表达式的关键：</p>
<p>在<code>Javascript</code>中</p>
<p>正则表达式是用来进行文本匹配相关操作的一个特殊的内建对象</p>
<ul>
<li>匹配自身的的原义字符</li>
<li>匹配特殊字符或者调整匹配逻辑的元字符</li>
</ul>
<p>这两种字符的组合成正则表达式的正文，配合修饰符，去匹配字符串中的文本字段</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都爱正则表达式，但是一个个奇怪字符的组合总是让我这种弱鸡感到难以领悟。&lt;/p&gt;
&lt;p&gt;每次看到一个正则匹配式却理解不了，我都安慰自己：“反正我已经知道它是用来匹配文本的”&lt;/p&gt;
&lt;p&gt;为什么不现在直接把它学会呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="develop" scheme="http://lumpychen.github.io/tags/develop/"/>
    
  </entry>
  
  <entry>
    <title>Econometrics - Regression</title>
    <link href="http://lumpychen.github.io/2016/en/Econometrics-regression/"/>
    <id>http://lumpychen.github.io/2016/en/Econometrics-regression/</id>
    <published>2016-09-18T07:05:31.000Z</published>
    <updated>2016-10-15T08:27:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><blockquote><p>“Econometrics, literally “econometric measurement”, is the quantitative measurement and analysis of actual econometric and business phenomena.”</p>
<footer><strong>-- A.H.Studenmund</strong></footer></blockquote>
<p>This article contains notes of this lesson.</p>
<a id="more"></a>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Econometrics is a combination of <code>mathematics</code>, <code>economics</code> and <code>statistics</code>.<br>Econometrics 3 uses:</p>
<ul>
<li>describing economic reality.</li>
<li>testing hypotheses about economic theory.</li>
<li>forecasting future economic activity.</li>
</ul>
<h2 id="Single-Regression"><a href="#Single-Regression" class="headerlink" title="Single Regression"></a>Single Regression</h2><blockquote><p>“To predict the <em>direction</em> of change, you need a knowledge of economic theory and the general characteristics of the product in question. To predict the <em>amount</em> of the change, though, you need a sample of data, and you need a way to estimate the relationship.”</p>
<footer><strong>A.H.Studenmund</strong><cite>-- Using Econometrics: A Pratical Guide</cite></footer></blockquote>
<p>The most frequently used method to estimate such a relationship in econometrics is <em>regression analysis</em>.</p>
<p>Regression Analysis:</p>
<ul>
<li>Dependent Variables</li>
<li>Independent Variables</li>
<li>Causality</li>
</ul>
<p>Aim at <code>Gross mean value</code> of dependent value, and <code>dependent relationship</code> of variable. (not <code>cause-and-effect relationship</code>)</p>
<p>$$Q_i=\beta_1 X_i + \beta_0 + \varepsilon_i, i=1,2,3…,N$$</p>
<ul>
<li>\(Q_i\) – The i th observation of the dependent variable.</li>
<li>\(X\) – The i th observation of the independent Variable.</li>
<li>\(\beta_0\) – Intercept(Constant)</li>
<li>\(\beta_1\) – Coefficient</li>
<li>\(\varepsilon_i\) – The i th observation of the stochastic error term (deviation).</li>
<li>\(N\) – The Number of observations.</li>
</ul>
<p>deterministic component &amp; Stochastic component:</p>
<p>$$ Y = E(Y|X) + \varepsilon = \beta_1 X + \beta_0 $$</p>
<p>We prefer linear equations to nonlinear, so if the relationship we analysis is not linear, we can doing the redefination like: \(z=x^2\).</p>
<p>After understanding the theoretical regression equation, it can be quantified to a estimated regression equation.</p>
<h2 id="Muti-Regression"><a href="#Muti-Regression" class="headerlink" title="Muti Regression"></a>Muti Regression</h2><p>$$ Y_i = \beta_0 + \beta_1 X_{i1} + \beta_2 X_{i2} + \varepsilon_i $$</p>
<p>For instance, here goes a multivariate linear regression model expression.</p>
<p>\(\beta_1\) in the equation means how much Y increases as every unit \(X_1\) increases and \(X_2\) stays still.</p>
<p>\(i\) represents the observation series, from 1 to \(N\)</p>
<h2 id="Estimation"><a href="#Estimation" class="headerlink" title="Estimation"></a>Estimation</h2><p>$$ \hat{Y_i} = 103.40 + 6.38 X_i $$</p>
<p>The variable with the hat symbol means the regression value.</p>
<p>Differences of theoretical regression equation &amp; estimated regression equation:</p>
<table>
<thead>
<tr>
<th style="text-align:center">\</th>
<th style="text-align:center">Theoretical equation</th>
<th style="text-align:center">Estimated equation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Expression</td>
<td style="text-align:center">\(Y_i=\beta_0+\beta_1 X_i + \varepsilon_i\)</td>
<td style="text-align:center">\(\hat{Y_i}=\hat{\beta_0}+\hat{\beta_1}X_i\)</td>
</tr>
<tr>
<td style="text-align:center">Calculated expression</td>
<td style="text-align:center">-</td>
<td style="text-align:center">\(\hat{Y_i}=103.40+6.38X_i\)</td>
</tr>
<tr>
<td style="text-align:center">Base data</td>
<td style="text-align:center">-</td>
<td style="text-align:center">A sample of the Xs &amp; Ys</td>
</tr>
<tr>
<td style="text-align:center">Coefficient</td>
<td style="text-align:center">\(\beta\)</td>
<td style="text-align:center">calculated estimate values: 103.40</td>
</tr>
</tbody>
</table>
<p>The difference between error term &amp; residual:</p>
<table>
<thead>
<tr>
<th style="text-align:center">\</th>
<th style="text-align:center">Error term</th>
<th style="text-align:center">Residual</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Error term/Residual</td>
<td style="text-align:center">\(\varepsilon_i=Y_i-E(Y_i &#124; X_i)\)</td>
<td style="text-align:center">\(e_i=Y_i - \hat{Y_i}\)</td>
</tr>
<tr>
<td style="text-align:center">what it means</td>
<td style="text-align:center">The difference between the observed \(Y\) &amp; estimated \(\hat{Y}\)</td>
<td style="text-align:center">The difference between the observed \(Y\) &amp; the regression expected value of \(Y\)</td>
</tr>
<tr>
<td style="text-align:center">Nature</td>
<td style="text-align:center">A theoretical concept which can’t be calculated.</td>
<td style="text-align:center">The estimate of \(\varepsilon\), each observation every time a regression runs</td>
</tr>
<tr>
<td style="text-align:center">Line</td>
<td style="text-align:center">True line</td>
<td style="text-align:center">Estimated line</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;“Econometrics, literally “econometric measurement”, is the quantitative measurement and analysis of actual econometric and business phenomena.”&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;-- A.H.Studenmund&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;p&gt;This article contains notes of this lesson.&lt;/p&gt;
    
    </summary>
    
    
      <category term="course" scheme="http://lumpychen.github.io/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>2016末学习计划</title>
    <link href="http://lumpychen.github.io/2016/zh-cn/2016%E6%9C%AB%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>http://lumpychen.github.io/2016/zh-cn/2016末学习计划/</id>
    <published>2016-09-18T05:44:21.000Z</published>
    <updated>2016-09-18T07:03:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p>不得不说大三是个比较关键的时期。</p>
<p>虽然就业的压力现在对我来说没那么大了，但是我需要更多的选择来获得更好的环境。</p>
<p>当然，于兴趣而言，我肯定也会搞一些事出来。</p>
<blockquote>
<p>“提升自己真的比什么都重要啊……”</p>
</blockquote>
<a id="more"></a>
<h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><p>我需要领悟这几个课程的关键：</p>
<ul>
<li>中级微观经济学</li>
<li>计量经济学</li>
<li>金融衍生工具</li>
</ul>
<p>还有<a href="http://www.xuetangx.com" target="_blank" rel="external">学堂在线</a>上的课程：</p>
<ul>
<li>数据结构与算法</li>
<li>操作系统原理</li>
<li>计算机网络</li>
<li>编译原理</li>
</ul>
<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul>
<li><a href="https://book.douban.com/subject/25869486/" target="_blank" rel="external"><em>Practical Vim</em></a>–<strong>Drew Neil</strong></li>
<li><a href="https://book.douban.com/subject/4253716/" target="_blank" rel="external"><em>Guide to Unix and Linux</em></a>–<strong>Harley Hahns</strong></li>
<li><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="external"><em>HTTP权威指南</em></a>–<strong>David Gourley</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不得不说大三是个比较关键的时期。&lt;/p&gt;
&lt;p&gt;虽然就业的压力现在对我来说没那么大了，但是我需要更多的选择来获得更好的环境。&lt;/p&gt;
&lt;p&gt;当然，于兴趣而言，我肯定也会搞一些事出来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“提升自己真的比什么都重要啊……”&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="arrangement" scheme="http://lumpychen.github.io/tags/arrangement/"/>
    
      <category term="course" scheme="http://lumpychen.github.io/tags/course/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://lumpychen.github.io/2016/en/hello-world/"/>
    <id>http://lumpychen.github.io/2016/en/hello-world/</id>
    <published>2016-09-18T00:55:32.000Z</published>
    <updated>2016-09-18T00:55:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/owl.css&quot;&gt;&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very f
    
    </summary>
    
    
      <category term="useless" scheme="http://lumpychen.github.io/tags/useless/"/>
    
      <category term="en" scheme="http://lumpychen.github.io/tags/en/"/>
    
  </entry>
  
  <entry>
    <title>Apollo样式测试</title>
    <link href="http://lumpychen.github.io/2016/zh-cn/Apollo%E6%A0%B7%E5%BC%8F%E6%B5%8B%E8%AF%95/"/>
    <id>http://lumpychen.github.io/2016/zh-cn/Apollo样式测试/</id>
    <published>2016-09-17T07:03:29.000Z</published>
    <updated>2016-09-18T01:40:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p>我可以在这里写一点东西作为主页的摘要，然而不方便融入<code>Markdown</code>语法的规范。<br><a id="more"></a></p>
<hr>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p><em>斜体字</em></p>
<p><strong> 粗体字</strong></p>
<p>无序列表：</p>
<ul>
<li>无序1</li>
<li>无序2</li>
<li>无序3</li>
</ul>
<p>有序列表：</p>
<ol>
<li>有序1</li>
<li>有序2</li>
<li>有序3<ol>
<li>缩进层级1<ol>
<li>缩进层级2</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>“我引用了一段话。”</p>
</blockquote>
<blockquote><p>“我引用了自己所说的一段话。”</p>
<footer><strong>@Lumpy -</strong><cite><a href="http://www.lumpychen.com" target="_blank" rel="external">www.lumpychen.com</a></cite></footer></blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> user = <span class="string">'lumpy'</span></div><div class="line"><span class="keyword">const</span> speakName = (name) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> speakName</div></pre></td></tr></table></figure>
<p>我写了一段<code>JavaScript</code>代码。</p>
<p>$$\frac{1}{9}\int_{1}^{10}X^2$$</p>
<p>我写了一个数学公式，<code>MathJax</code>发挥了它的效果。</p>
<div class="tip">而这里有一些要注意的地方。</div>

<p>表格</p>
<table>
<thead>
<tr>
<th style="text-align:center">存货种类</th>
<th style="text-align:center">仓库1</th>
<th style="text-align:center">仓库2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">面包</td>
<td style="text-align:center">100</td>
<td style="text-align:center">200</td>
</tr>
<tr>
<td style="text-align:center">火腿</td>
<td style="text-align:center">90</td>
<td style="text-align:center">102</td>
</tr>
</tbody>
</table>
<p>我们别忘了插入音乐</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="http://music.163.com/outchain/player?type=2&id=2309174&auto=0&height=32"></iframe>
<p>以及图片</p>
<p><img src="http://cdn.quotesgram.com/img/0/51/2004674841-i-was-born-to-make-mistakes-a-drake-quotes-about-love-wonderful-drake-quotes-about-love-930x620.jpg" alt="jaime"></p>
<p>甚至视频</p>
<div class="owl-media owl-video owl-bilibili"><embed src="http://static.hdslb.com/miniloader.swf" flashvars="aid=6320264&page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" type="application/x-shockwave-flash" quality="high" allowfullscreen="true"></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我可以在这里写一点东西作为主页的摘要，然而不方便融入&lt;code&gt;Markdown&lt;/code&gt;语法的规范。&lt;br&gt;
    
    </summary>
    
    
      <category term="useless" scheme="http://lumpychen.github.io/tags/useless/"/>
    
  </entry>
  
</feed>
