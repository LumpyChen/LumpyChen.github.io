<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LANTAU</title>
  
  <subtitle>Lavish angel never tell about u.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lumpychen.github.io/"/>
  <updated>2017-12-24T15:36:25.717Z</updated>
  <id>http://lumpychen.github.io/</id>
  
  <author>
    <name>Lumpy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的Emacs键位汇总</title>
    <link href="http://lumpychen.github.io/2017/zh-cn/%E6%88%91%E7%9A%84Emacs%E9%94%AE%E4%BD%8D%E6%B1%87%E6%80%BB/"/>
    <id>http://lumpychen.github.io/2017/zh-cn/我的Emacs键位汇总/</id>
    <published>2017-12-23T16:00:00.000Z</published>
    <updated>2017-12-24T15:36:25.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p>由于大四这段时间事情相对来说不多（😂仅仅是相对来说），我开始学习<code>emacs</code>了，学会这个强大的工具可以很好的提高自己的效率，同时学会它的过程也会提高自己学习工具的能力。</p><p>我使用<code>Spacemacs</code>的配置，同时加以自己的<code>layer</code>，这样的话整个配置会便于管理，我<code>spacemacs</code>的配置可以在<a href="https://github.com/LumpyChen/spacemacs-private" target="_blank" rel="noopener">这里</a>找到</p><p>同时这是我最后一篇使用<code>markdown</code>的文章，之后的文章都会使用<code>emacs</code>的<code>org-mode</code>来完成。</p><a id="more"></a><h2 id="输入操作"><a class="markdownIt-Anchor" href="#输入操作"></a> 输入操作</h2><h3 id="evil-args"><a class="markdownIt-Anchor" href="#evil-args"></a> evil-args</h3><p><code>evil-args</code>可以很好地操作函数参数</p><ul><li><code>[cia]</code>：修改当前参数</li><li><code>[daa]</code>：删除当前参数</li><li><code>[L]</code>：跳转到下一个参数</li><li><code>[H]</code>：跳转到上一个参数</li><li><code>[K]</code>：从参数跳转到函数名首</li></ul><h3 id="smartparens"><a class="markdownIt-Anchor" href="#smartparens"></a> Smartparens</h3><p><code>Smartparens</code>是一个用来控制括号的小工具。</p><h3 id="surrounding"><a class="markdownIt-Anchor" href="#surrounding"></a> Surrounding</h3><p><code>Surrounding</code>是一个快速修改配对文本的小工具。</p><ul><li><code>[ys + 文本对象 + 字符]</code>：将特定字符包围某文本对象</li><li><code>[Ys + 文本对象 + 字符]</code>：将特定字符包围某文本对象（另起一行）</li><li><code>[ds + 字符]</code>：删除包围的某个特定字符</li><li><code>[cs + 老字符 + 新字符]</code>：删除被包围的某特定字符换成另一个</li><li>在可视模式下，<code>s</code>也可以直接生效</li></ul><p>特殊含义字符：</p><ul><li><code>f</code>：将文本对象作为函数的参数</li><li><code>t</code>：将文本对象用<code>html</code>标签包围</li><li>反向的标签字符会多一个空格</li></ul><h2 id="帮助指令"><a class="markdownIt-Anchor" href="#帮助指令"></a> 帮助指令</h2><p>这些指令其实是最重要的……因为自己要从各种<code>README</code>开始学习。</p><ul><li><code>[spc h spc]</code>：寻找相关内容在<code>Emacs</code>配置中的初始函数</li><li><code>[spc h f]</code>：查看<code>Emacs</code>中的常见问题</li><li><code>[spc h l]</code>：查看<code>layer</code>的文档</li><li><code>[spc h r]</code>：打开<code>spacemacs</code>文档中章节</li><li><code>[spc h R]</code>：在所有文档中进行搜索</li><li><code>[spc h k]</code>：展示目前的可用热键</li></ul><h3 id="描述功能"><a class="markdownIt-Anchor" href="#描述功能"></a> 描述功能</h3><ul><li><code>[spc h d b]</code>：描述组合键</li><li><code>[spc h d c]</code>：描述当前选择字符</li><li><code>[spc h d f]</code>：描述函数</li><li><code>[spc h d v]</code>：描述变量</li><li><code>[spc h d p/P]</code>：从<code>Emacs</code>文档/<code>spacemacs</code>文档中描述包</li><li><code>[spc h d k]</code>：记录按键并进行描述</li><li><code>[spc h d K]</code>：描述某个快捷键系列</li><li><code>[spc h d m]</code>：查看当前的<code>mode</code></li></ul><h2 id="文件操作"><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h2><ul><li><code>[spc p f]</code>：在当前工程中查询文件(project find)</li><li><code>[spc f f]</code>：在当前目录下查询文件，使用<code>[C h]</code>可以跳到上级目录(file find)</li><li><code>[spc f L]</code>：在整个<code>Mac</code>系统寻找文件(file locate)</li><li><code>[spc f h]</code>：查询文件用二进制打开，使用<code>[C c]</code>两次可返回正常模式(file hex)</li><li><code>[spc f o]</code>：使用系统默认程序打开文件(file open)</li><li><code>[spc f E]</code>：查询文件<code>sudo</code>打开进行编辑(file sudo-Edit)</li><li><code>[spc f D]</code>：删除当前的文件和缓冲区(file delete)</li><li><code>[spc f j]</code>：使用<code>Dired</code>打开当前目录(file jump)</li><li><code>[spc f t]</code>：使用<code>Treemacs</code>打开当前目录，再次则关闭(file tree)</li><li><code>[spc f C-t]</code>：同上，但是光标保持在当前列表</li><li><code>[spc f r]</code>：打开最近打开过的文件列表(file recent)</li><li><code>[spc f R]</code>：重命名当前文件(file rename)</li><li><code>[spc f v]</code>：为当前目录/文件添加本地变量，会添加当前目录的一个文件(file variable)</li><li><code>[spc f y]</code>：拷贝当前文件路径(file yank)</li><li><code>[spc f C u/d]</code>：将当前文件的编码转化为<code>unix/dos</code>版本(file convert unix/dos)</li><li><code>[spc f e d/i]</code>：打开&quot;<sub>/.spacemacs/init.el&quot;或者&quot;</sub>/.emacs.d/init.el&quot;(file emacs dotfile/initfile)</li><li><code>[spc f c]</code>：复制文件另存为(file copy)</li></ul><h3 id="treemacs"><a class="markdownIt-Anchor" href="#treemacs"></a> Treemacs</h3><blockquote><p><code>Treemacs</code>是在屏幕左侧出现，便于用户进行文件管理的侧边栏。</p></blockquote><h4 id="节点选择"><a class="markdownIt-Anchor" href="#节点选择"></a> 节点选择</h4><ul><li><code>j/k</code>：光标下移/上移</li><li><code>u</code>：如果当前树上有选中文件的父节点，则跳转过去</li><li><code>h</code>：将当前树的根节点向上移动一级</li><li><code>l</code>：将当前树的根节点切换到选中文件</li></ul><h4 id="节点打开"><a class="markdownIt-Anchor" href="#节点打开"></a> 节点打开</h4><ul><li><code>tab</code>：展开/闭合目录或者文件</li><li><code>return</code>：展开/闭合目录或者打开文件</li><li><code>o h</code>：水平新建屏幕打开文件，用<code>dired</code>打开目录</li><li><code>o v</code>：垂直新建屏幕打开文件，用<code>dired</code>打开目录</li><li><code>o x</code>：根据文件的扩展名使用系统应用打开文件</li></ul><h4 id="节点操作"><a class="markdownIt-Anchor" href="#节点操作"></a> 节点操作</h4><ul><li><code>c f</code>：新建文件</li><li><code>c d</code>：新建目录</li><li><code>R</code>：重命名文件</li></ul><h4 id="显示选择"><a class="markdownIt-Anchor" href="#显示选择"></a> 显示选择</h4><ul><li><code>g r</code>：刷新目录</li><li><code>w</code>：重设宽度</li><li><code>y y</code>：拷贝当前文件路径</li><li><code>y r</code>：拷贝当前根目录路径</li><li><code>s</code>：按照特殊标准重新排列文件</li></ul><h3 id="dired"><a class="markdownIt-Anchor" href="#dired"></a> Dired</h3><blockquote><p><code>Dired</code>可以全屏进行对文件的操作。</p></blockquote><h4 id="访问操作"><a class="markdownIt-Anchor" href="#访问操作"></a> 访问操作</h4><ul><li><code>f</code>/<code>e</code>/<code>ret</code>：访问当前文件</li><li><code>o</code>：在另一个窗体访问当前文件</li><li><code>C - o</code>：在另一个窗体访问当前文件，同时光标保持在原来的窗体</li><li><code>v</code>：只读模式访问当前文件</li><li><code>^</code>：向上一级</li></ul><h4 id="标记操作"><a class="markdownIt-Anchor" href="#标记操作"></a> 标记操作</h4><ul><li><code>u</code>：取消当前标记</li><li><code>x</code>：执行所有标记</li><li><code>d</code>：删除文件</li></ul><h4 id="即时操作"><a class="markdownIt-Anchor" href="#即时操作"></a> 即时操作</h4><ul><li><code>+</code>：创建新的目录</li><li><code>g</code>：刷新目录</li><li><code>C</code>：拷贝</li><li><code>D</code>：删除</li><li><code>R</code>：重命名</li></ul><h2 id="缓冲区操作"><a class="markdownIt-Anchor" href="#缓冲区操作"></a> 缓冲区操作</h2><ul><li><code>[spc b .]</code>：打开缓冲区切换器(buffer micro)</li><li><code>[spc b b]</code>：查询已经打开的缓冲区(buffer buffer)</li><li><code>[spc b d]</code>：关闭当前缓冲区(buffer delete)</li><li><code>[spc b C-d]</code>：关闭匹配正则表达式的所有缓冲区(buffer reg delete)</li><li><code>[spc b f]</code>：在<code>finder</code>中打开当前文件(buffer finder)</li><li><code>[spc b h/s]</code>：打开<code>spacemacs</code>的主页缓冲区/<code>scratch</code>缓冲区(buffer home/scratch)</li><li><code>[spc b m]</code>：删除除了当前缓冲区外的所有缓冲区(buffer murder)</li><li><code>[spc b N]</code>：新建缓冲区(buffer new)</li><li><code>[spc b R]</code>：使用自动备份来还原缓冲区(buffer recover buffer)</li><li><code>[spc b w]</code>：把当前缓冲区变为只读(buffer none-write)</li><li><code>[spc tab]</code>：切换至上一个打开的缓冲区(buffer toggle)</li></ul><h2 id="布局操作"><a class="markdownIt-Anchor" href="#布局操作"></a> 布局操作</h2><ul><li><code>[spc l l]</code>：查询并切换到布局(layout layout)</li><li><code>[spc l 1...9]</code>：跳转到指定布局</li><li><code>[spc l n/p]</code>：切换至上一个/下一个布局(layout next/previous)</li><li><code>[spc l L]</code>：导入布局文件(layout load)</li><li><code>[spc l s]</code>：保存当前布局为一个文件(layout save)</li><li><code>[spc l tab]</code>： 打开上一个布局(layout toggle)</li><li><code>[spc l R]</code>：重命名当前布局(layout rename)</li></ul><h2 id="窗体操作"><a class="markdownIt-Anchor" href="#窗体操作"></a> 窗体操作</h2><ul><li><code>[spc w -]</code>：下面新建窗体</li><li><code>[spc w /]</code>：右边新建窗体</li><li><code>[spc w .]</code>：进入窗体转换器</li><li><code>[spc 1...9]</code>：光标跳跃到第1-9个窗体</li><li><code>[spc w h/j/k/l/tab/W]</code>：窗体切换(window other)</li><li><code>[spc w w]</code>：切换到另一个窗体</li><li><code>[spc H/J/K/L]</code>：将窗体进行移动</li><li><code>[spc w b]</code>：将光标跳跃到<code>mini-buffer</code></li><li><code>[spc w =]</code>：将窗体的宽度和高度等分</li><li><code>[spc w m]</code>：最大化当前窗体(window maximized)</li><li><code>[spc w d]</code>：删除当前窗体(window delete)</li><li><code>[spc w u/U]</code>：窗体的操作撤销/重复(window undo)</li><li><code>[spc t g]</code>：窗体黄金分割(toggle golden ratio)</li><li><code>[spc t -]</code>：光标在窗体中保持中间</li></ul><h2 id="工程操作"><a class="markdownIt-Anchor" href="#工程操作"></a> 工程操作</h2><ul><li><code>[spc p f]</code>：查询并打开工程里的文件(project file)</li><li><code>[spc p b]</code>：查询并打开工程里的缓冲区(project buffer)</li><li><code>[spc p p]</code>：查询并打开工程(project project)</li><li><code>[spc p l]</code>：查询并打开工程，创建新的布局(project layout)</li><li><code>[spc s p]</code>：在该工程中进行字符串搜索</li></ul><h2 id="跳跃操作"><a class="markdownIt-Anchor" href="#跳跃操作"></a> 跳跃操作</h2><ul><li><code>[spc j j]</code>：将光标跳跃到屏幕中某个位置，之后输入一个字符作为索引，可以当做拼音，再进行选择</li><li><code>[spc j l]</code>：跳跃到指定一行，根据屏幕进行选择</li><li><code>[spc j s/S]</code>：分割当前括号层级变为两个（分割到另一行）</li><li><code>[spc j i]</code>：打开<code>imenu</code>，在当前文章中进行段落跳跃</li></ul><h2 id="javascript相关操作"><a class="markdownIt-Anchor" href="#javascript相关操作"></a> Javascript相关操作</h2><ul><li><code>[spc t s]</code>：允许/禁止<code>flycheck</code>进行语法检查（默认使用<code>eslint</code>）</li><li><code>[spc t t]</code>：显示/隐藏<code>flycheck</code>语法检查错误的缓冲区</li></ul><h3 id="ctags相关操作"><a class="markdownIt-Anchor" href="#ctags相关操作"></a> Ctags相关操作</h3><ul><li><code>[g ]]</code>：使用<code>etags</code>查找当前<code>tag</code></li></ul><h2 id="内置应用操作"><a class="markdownIt-Anchor" href="#内置应用操作"></a> 内置应用操作</h2><h3 id="博客操作"><a class="markdownIt-Anchor" href="#博客操作"></a> 博客操作</h3><ul><li><code>[spc a b]</code>：使用<code>blog-admin</code>打开我的博客</li></ul><h3 id="emoji操作"><a class="markdownIt-Anchor" href="#emoji操作"></a> Emoji操作</h3><ul><li><code>[spc a E]</code>：打开插入<code>Emoji</code>的缓冲区，回车进行拷贝，<code>q</code>退出</li><li><code>[spc i e]</code>：使用<code>Helm</code>来插入<code>Emoji</code></li></ul><h3 id="印象笔记操作"><a class="markdownIt-Anchor" href="#印象笔记操作"></a> 印象笔记操作</h3><blockquote><p>安装<code>spacemacs</code>的<code>evernote-layer</code>，再在本地安装<code>geeknote</code>，把配置里面的服务器地址从<code>www.evernote.com</code>改成<code>app.yinxiang.com</code>即可</p></blockquote><ul><li><code>[spc a e c]</code>：创建新笔记，使用<code>@</code>指定笔记本，使用<code>#</code>指定标签</li><li><code>[spc a e f]</code>：查找笔记（通过标题和内容），在结果的缓冲区可以使用下面四个指令加上结果中的序号作为参数</li><li><code>[spc a e e]</code>：编辑指定名称的笔记</li><li><code>[spc a e s]</code>：只读预览指定名称的笔记</li><li><code>[spc a e r]</code>：删除指定名称的笔记</li><li><code>[spc a e m]</code>：移动指定名称的笔记到别的笔记本</li></ul><p>进入笔记缓冲区后，可以使用<code>markdown</code>语法进行编辑，保存后将会更新笔记到印象笔记，完成编辑后使用<code>[C-x #]</code>来结束编辑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于大四这段时间事情相对来说不多（😂仅仅是相对来说），我开始学习&lt;code&gt;emacs&lt;/code&gt;了，学会这个强大的工具可以很好的提高自己的效率，同时学会它的过程也会提高自己学习工具的能力。&lt;/p&gt;
&lt;p&gt;我使用&lt;code&gt;Spacemacs&lt;/code&gt;的配置，同时加以自己的&lt;code&gt;layer&lt;/code&gt;，这样的话整个配置会便于管理，我&lt;code&gt;spacemacs&lt;/code&gt;的配置可以在&lt;a href=&quot;https://github.com/LumpyChen/spacemacs-private&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;找到&lt;/p&gt;
&lt;p&gt;同时这是我最后一篇使用&lt;code&gt;markdown&lt;/code&gt;的文章，之后的文章都会使用&lt;code&gt;emacs&lt;/code&gt;的&lt;code&gt;org-mode&lt;/code&gt;来完成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="emacs" scheme="http://lumpychen.github.io/tags/emacs/"/>
    
      <category term="workflow" scheme="http://lumpychen.github.io/tags/workflow/"/>
    
  </entry>
  
  <entry>
    <title>org-test</title>
    <link href="http://lumpychen.github.io/2017/zh-cn/org-test/"/>
    <id>http://lumpychen.github.io/2017/zh-cn/org-test/</id>
    <published>2017-12-09T00:00:00.000Z</published>
    <updated>2017-12-10T18:18:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p><code>Emacs</code> 的 <code>org-mode</code> 是非常强大的工具，阅读了<a href="http://weychen.github.io/2016/09/28/set-up-blog-with-hexo-org-mode/" target="_blank" rel="noopener"> <i>weychen</i> 的文章之后</a> 我按照文章的流程搭建了我的工作流，同时写下了这篇文章去简单介绍下 <code>org-mode</code> 的语法。</p><a id="more"></a><div id="outline-container-sec-1" class="outline-2"><h2 id="sec-1">Org-mode实例</h2><div class="outline-text-2" id="text-1"></div><div id="outline-container-sec-1-1" class="outline-3"><h3 id="sec-1-1">标题</h3><div class="outline-text-3" id="text-1-1"><p>使用星号还表示第一级到第六级的标题，星号数目代表等级，星号与代码之间需要空格。</p></div><div id="outline-container-sec-1-1-1" class="outline-4"><h4 id="sec-1-1-1">第三级标题</h4><div class="outline-text-4" id="text-1-1-1"></div><ul class="org-ul"><li><a id="sec-1-1-1-1" name="sec-1-1-1-1"></a>第四级标题<br><ul class="org-ul"><li><a id="sec-1-1-1-1-1" name="sec-1-1-1-1-1"></a>第五级标题<br><ul class="org-ul"><li><a id="sec-1-1-1-1-1-1" name="sec-1-1-1-1-1-1"></a>第六级标题<br></li></ul></li></ul></li></ul></div></div><div id="outline-container-sec-1-2" class="outline-3"><h3 id="sec-1-2">超级链接</h3><div class="outline-text-3" id="text-1-2"><p><a href="http://www.baidu.com" target="_blank" rel="noopener">到百度的超级链接</a></p></div></div><div id="outline-container-sec-1-3" class="outline-3"><h3 id="sec-1-3">图片</h3><div class="outline-text-3" id="text-1-3"><div class="figure"><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1513526871&di=fe558010c532b3ff429b2e74dd8ad5de&imgtype=jpg&er=1&src=http://images.bookdao.com/bk/110207/1/42d1c2f6-156e-4f25-9d7c-76ab0c1c366d.jpg" alt="42d1c2f6-156e-4f25-9d7c-76ab0c1c366d.jpg"></p></div></div></div><div id="outline-container-sec-1-4" class="outline-3"><h3 id="sec-1-4">列表</h3><div class="outline-text-3" id="text-1-4"></div><div id="outline-container-sec-1-4-1" class="outline-4"><h4 id="sec-1-4-1">无序列表</h4><div class="outline-text-4" id="text-1-4-1"><p>加号可以用来生成无序列表，列表之间的父子等级可以使用缩进来表示。</p><ul class="org-ul"><li>无序列表1</li><li>无序列表2</li><li>无序列表3<ul class="org-ul"><li>无序子列表1</li><li>无序子列表2</li><li>无序子列表3</li></ul></li><li>无序列表4</li></ul></div></div><div id="outline-container-sec-1-4-2" class="outline-4"><h4 id="sec-1-4-2">有序列表</h4><div class="outline-text-4" id="text-1-4-2"><ol class="org-ol"><li>有序列表1</li><li>有序列表2</li><li>有序列表3<ol class="org-ol"><li>有序子列表1</li><li>有序字列表2</li><li>有序字列表3</li></ol></li></ol></div></div></div><div id="outline-container-sec-1-5" class="outline-3"><h3 id="sec-1-5">抽屉</h3><div class="outline-text-3" id="text-1-5"><p>这是一个抽屉</p><p>:SECRET:</p><p>抽屉里面藏着秘密</p><p>:END:</p><p>抽屉结束</p></div></div><div id="outline-container-sec-1-6" class="outline-3"><h3 id="sec-1-6">字体</h3><div class="outline-text-3" id="text-1-6"><p>粗体： <b>bold</b></p><p>斜体： <i>italic</i></p><p>下划线： <span class="underline">underline</span></p><p>代码： <code>code</code></p><p>逐字解析： <code>verbatim</code></p><p>删除线： <del>strike-through</del></p></div></div><div id="outline-container-sec-1-7" class="outline-3"><h3 id="sec-1-7">脚注</h3><div class="outline-text-3" id="text-1-7"><p>这是一个脚注<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup></p></div></div><div id="outline-container-sec-1-8" class="outline-3"><h3 id="sec-1-8">注释</h3><div class="outline-text-3" id="text-1-8"><p>单行注释：</p><p>多行注释：</p></div></div><div id="outline-container-sec-1-9" class="outline-3"><h3 id="sec-1-9">引用</h3><div class="outline-text-3" id="text-1-9"><p>引用文字：</p><blockquote><p>引用了一些文字<br>另一行引用的文字同一行引用的文字</p></blockquote><p>段落之间至少要有一空行。如果你想实现段内分行，可以在行后加上 <code>\\</code> <br>或者采用正常格式化分行：</p><p class="verse">Great clouds overhead<br>Tiny black birds rise and fall<br>Snow covers Emacs<br><br>&#xa0;&#xa0;&#xa0;&#xa0;&#x2013; AlexSchroeder<br></p><p>文本居中：</p><div class="center"><p>Everything should be made as simple as possible, <br>but not any simpler</p></div></div></div><div id="outline-container-sec-1-10" class="outline-3"><h3 id="sec-1-10">纯文本</h3><div class="outline-text-3" id="text-1-10"><p>一般纯文本：</p><pre class="example">里面的文字会等宽排版Here is an example   : Some example from a text file.</pre><p>代码插入：</p><div class="org-src-container"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">}</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></div></div></div><div id="outline-container-sec-1-11" class="outline-3"><h3 id="sec-1-11">表格</h3><div class="outline-text-3" id="text-1-11"><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col class="left"><col class="left"><col class="left"><col class="left"><col class="left"></colgroup><thead><tr><th scope="col" class="left">Name</th><th scope="col" class="left">Phone</th><th scope="col" class="left">sub1</th><th scope="col" class="left">sub2</th><th scope="col" class="left">total</th></tr></thead><tbody><tr><td class="left">Ali</td><td class="left">134****</td><td class="left">aaa</td><td class="left">bbb</td><td class="left">aaabbb</td></tr><tr><td class="left">Bill</td><td class="left">138****</td><td class="left">aaaa</td><td class="left">bbbb</td><td class="left">aaaabbbb</td></tr></tbody></table></div></div><div id="outline-container-sec-1-12" class="outline-3"><h3 id="sec-1-12">公式</h3><div class="outline-text-3" id="text-1-12"></div><div id="outline-container-sec-1-12-1" class="outline-4"><h4 id="sec-1-12-1">简单符号</h4><div class="outline-text-4" id="text-1-12-1"><p>简单的符号可以直接使用，包括直接转义的符号字母和数字上下标</p><p>希腊字母：</p><p>&alpha;, &beta; and &gamma;. </p><p>下标：</p><p>a<sub>1</sub>&times; a<sub>2</sub><sup>2</sup></p></div></div><div id="outline-container-sec-1-12-2" class="outline-4"><h4 id="sec-1-12-2">公式和方程组块状居中</h4><div class="outline-text-4" id="text-1-12-2">\begin{equation}  \sum\limits_{i=1}^n(单项评分_i * 权重)  \end{equation}  \begin{equation}  \frac{1^p+2^p+\cdot\cdot\cdot+n^p}{n^{1+p}}  \end{equation}  \begin{equation}  \stackrel{abc}{\longrightarrow}  \end{equation}  \begin{equation}  Y=\left\{  \begin{aligned}  +1 & , & if & & X \geq \theta \\  -1 & , & if & & X < \theta  \end{aligned}  \right.  \end{equation}  </div></div><div id="outline-container-sec-1-12-3" class="outline-4"><h4 id="sec-1-12-3">公式和方程组嵌入语句</h4><div class="outline-text-4" id="text-1-12-3"><p>我们可以看到这个流程 \(op_1\stackrel{abc}{\longrightarrow}op_2\) 以及 \(\sum\limits_{i=1}^n(单项评分_i * 权重)\) </p></div></div></div><div id="outline-container-sec-1-13" class="outline-3"><h3 id="sec-1-13">Apollo的样式</h3><div class="outline-text-3" id="text-1-13"><p><div class="tip">警示仍然有效</div></p><p><blockquote><p>“我引用了自己所说的一段话。”</p><footer><strong>@Lumpy - <a href="http://www.lumpychen.com" target="_blank" rel="noopener">http://www.lumpychen.com</a></strong></footer></blockquote></p><p>音乐和视频也依然有效：</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="http://music.163.com/outchain/player?type=2&id=2309174&auto=1&height=32"></iframe></p><p><div class="owl-media owl-video owl-tudou"><embed src="http://www.tudou.com/v/pRsx83aRLLs/&bid=05&resourceId=0_05_05_99/v.swf" allowscriptaccess="always" wmode="opaque" type="application/x-shockwave-flash" quality="high" allowfullscreen="true"></div></p></div></div></div><div id="footnotes"><h2 class="footnotes">Footnotes: </h2><div id="text-footnotes"><div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">The link is: <a href="http://orgmode.org" target="_blank" rel="noopener">http://orgmode.org</a></p></div></div></div>Last Updated 2017-12-11 一 02:18.<br>Render by <a href="https://github.com/CodeFalling/hexo-renderer-org" target="_blank" rel="noopener">hexo-renderer-org</a> with <a href="http://www.gnu.org/software/emacs/" target="_blank" rel="noopener">Emacs</a> 25.3.1 (<a href="http://orgmode.org" target="_blank" rel="noopener">Org</a> mode 8.2.10)]]></content>
    
    <summary type="html">
    
      &lt;p&gt;
&lt;code&gt;Emacs&lt;/code&gt; 的 &lt;code&gt;org-mode&lt;/code&gt; 是非常强大的工具，阅读了&lt;a href=&quot;http://weychen.github.io/2016/09/28/set-up-blog-with-hexo-org-mode/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; &lt;i&gt;weychen&lt;/i&gt; 的文章之后&lt;/a&gt; 我按照文章的流程搭建了我的工作流，同时写下了这篇文章去简单介绍下 &lt;code&gt;org-mode&lt;/code&gt; 的语法。
&lt;/p&gt;
    
    </summary>
    
    
      <category term="emacs" scheme="http://lumpychen.github.io/tags/emacs/"/>
    
      <category term="org" scheme="http://lumpychen.github.io/tags/org/"/>
    
  </entry>
  
  <entry>
    <title>JS版本的数据结构与算法</title>
    <link href="http://lumpychen.github.io/2017/zh-cn/JS%E7%89%88%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://lumpychen.github.io/2017/zh-cn/JS版本的数据结构与算法/</id>
    <published>2017-09-11T14:51:23.000Z</published>
    <updated>2017-09-17T12:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h4 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h4><blockquote><p>一个存储元素的线性的连续存储结构，元素可以通过索引来任意存取</p></blockquote><h4 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h4><blockquote><p>栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，具有后入先出的特点(LIFO)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">  <span class="keyword">this</span>.top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top++] = ele;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[--<span class="keyword">this</span>.top];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top<span class="number">-1</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.clear =  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.top = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.length = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.top;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决问题：</p><p>数制间的相互转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mulBase</span>(<span class="params">num, base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">     s.push(num % base);</span><br><span class="line">     num = <span class="built_in">Math</span>.floor(num /= base);</span><br><span class="line">  &#125; <span class="keyword">while</span> (num &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">var</span> converted = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">while</span> (s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     converted += s.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> converted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断回文数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; word.length; ++i) &#123;</span><br><span class="line">     s.push(word[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> rword = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">while</span> (s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     rword += s.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (word == rword) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h4><blockquote><p>队列是一种特殊的列表，不同的是队列只能在队尾插入元素，在队首删除元素，具有先进先出的特点(FIFO)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">  <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore.push(element);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.dequeue =  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.shift();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="number">0</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.back = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.dataStore.length<span class="number">-1</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> retStr = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</span><br><span class="line">       retStr += <span class="keyword">this</span>.dataStore[i] + <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retStr;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.empty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore.length == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优先队列</p><blockquote><p>在一般情况下，从队列中删除的元素，一定是率先入队的元素。但是也有一些使用队列的应用，在删除元素时不必遵守先进先出的约定，比如优先队列</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Patient</span>(<span class="params">name, code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.code = code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> priority = <span class="keyword">this</span>.dataStore[<span class="number">0</span>].code;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[i].code &lt; priority) &#123;</span><br><span class="line">      priority = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.splice(priority, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表-LinkList"><a href="#链表-LinkList" class="headerlink" title="链表(LinkList)"></a>链表(LinkList)</h4><p>数组不总是组织数据的最佳数据结构：</p><ul><li>在很多编程语言中，数组的长度是固定的，所以当数组已被填满时，再要加入新的元素就会非常困难</li><li>在数组中，添加和删除元素也很麻烦，因为需要将数组中的其他元素向前或向后平移，以反映数组刚刚进行了添加或删除操作</li><li>JavaScript中数组被实现成了对象，效率很低</li></ul><blockquote><p>链表是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继。指向另一个节点的引用叫做链</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.element = element;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>);</span><br><span class="line">  <span class="keyword">this</span>.find = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (currNode.element != item) &#123;</span><br><span class="line">       currNode = currNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currNode;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">newElement, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(newElement);</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.find(item);</span><br><span class="line">    newNode.next = current.next;</span><br><span class="line">    current.next = newNode;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prevNode = <span class="keyword">this</span>.findPrevious(item);</span><br><span class="line">    <span class="keyword">if</span> (!(prevNode.next == <span class="literal">null</span>)) &#123;</span><br><span class="line">        prevNode.next = prevNode.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.display = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (!(currNode.next == <span class="literal">null</span>)) &#123;</span><br><span class="line">       print(currNode.next.element);</span><br><span class="line">       currNode = currNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有</p><h4 id="字典-Dictionary"><a href="#字典-Dictionary" class="headerlink" title="字典(Dictionary)"></a>字典(Dictionary)</h4><blockquote><p>字典是一种以键值对形式存储数据的数据结构，就像电话号码簿里的名字和电话号码一样。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.datastore = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.datastore[key] = value;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.find = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.datastore[key];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">delete</span> <span class="keyword">this</span>.datastore[key];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.showAll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.datastore)) &#123;</span><br><span class="line">       print(key + <span class="string">" -&gt; "</span> + <span class="keyword">this</span>.datastore[key]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="散列-HashTable"><a href="#散列-HashTable" class="headerlink" title="散列(HashTable)"></a>散列(HashTable)</h4><blockquote><p>散列是一种常用的数据存储技术，每个键值映射为一个唯一的数组索引，散列后的数据可以快速地插入或取用非常快</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.table = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">137</span>);</span><br><span class="line">  <span class="keyword">this</span>.betterHash = <span class="function"><span class="keyword">function</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 霍纳算法，先计算字符串中各字符的 ASCII 码值，求和时每次要乘以一个质数</span></span><br><span class="line">    <span class="keyword">const</span> H = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.length; ++i) &#123;</span><br><span class="line">       total += H * total + string.charCodeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    total = total % <span class="keyword">this</span>.table.length;</span><br><span class="line">    <span class="keyword">if</span> (total &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       total += <span class="keyword">this</span>.table.length<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(total);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.showDistro = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.table.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.table[i] != <span class="literal">undefined</span>) &#123;</span><br><span class="line">        print(i + <span class="string">": "</span> + <span class="keyword">this</span>.table[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.put = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pos = <span class="keyword">this</span>.betterHash(data);</span><br><span class="line">    <span class="keyword">this</span>.table[pos] = data;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.table[<span class="keyword">this</span>.betterHash(key)];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>碰撞处理：开链法</p><blockquote><p>在创建存储散列过的键值的数组时，通过调用一个函数创建一个新的空数组，然后将该数组赋给散列表里的每个数组元素。这样就创建了一个二维数组，存储多个键</p></blockquote><p>挂载新的函数在散列上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildChains</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.table.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">this</span>.table[i] = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>put</code>方法将键值散列，散列后的值对应数组中的一个位置，先尝试将数据放到该位置上的数组中的第一个单元格，如果该单元格里已经有数据了，<code>put</code>方法会搜索下一个位置，直到找到能放置数据的单元格，并把数据存储进去<br><code>get</code>方法先对键值散列，根据散列后的值找到散列表中相应的位置，然后搜索该位置上的链，直到找到键值。如果找到，就将紧跟在键值后面的数据返回</p><p>碰撞处理：线性探索法</p><blockquote><p>当发生碰撞时，线性探测法检查散列表中的下一个位置是否为空。如果为空，就将数据存入该位置;如果不为空，则继续检查下一个位置，直到找到一个空的位置为止。该技术是基于这样一个事实:每个散列表都会有很多空的单元格，可以使用它们来存储数据</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params">key, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pos = <span class="keyword">this</span>.betterHash(key);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.table[pos] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">     <span class="keyword">this</span>.table[pos] = key;</span><br><span class="line">     <span class="keyword">this</span>.values[pos] = data;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.table[pos] != <span class="literal">undefined</span>) &#123;</span><br><span class="line">      pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.table[pos] = key;</span><br><span class="line">    <span class="keyword">this</span>.values[pos] = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> hash = <span class="number">-1</span>;</span><br><span class="line">  hash = <span class="keyword">this</span>.betterHash(key);</span><br><span class="line">  <span class="keyword">if</span> (hash &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = hash; <span class="keyword">this</span>.table[hash] != <span class="literal">undefined</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.table[hash] == key) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.values[hash];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合(Set)"></a>集合(Set)</h4><blockquote><p>集合是一种包含不同元素的数据结构。集合中的元素称为成员。集合的两个最重 要特性是:首先，集合中的成员是无序的;其次，集合中不允许相同成员存在</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore.indexOf(data) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">this</span>.dataStore.push(data);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pos = <span class="keyword">this</span>.dataStore.indexOf(data);</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dataStore.splice(pos, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.size = size;</span><br><span class="line">  <span class="comment">//this.contains、this.size略</span></span><br><span class="line">  <span class="keyword">this</span>.union = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tempSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</span><br><span class="line">       tempSet.add(<span class="keyword">this</span>.dataStore[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; set.dataStore.length; ++i) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!tempSet.contains(set.dataStore[i])) &#123;</span><br><span class="line">          tempSet.dataStore.push(set.dataStore[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempSet;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.intersect =  <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tempSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (set.contains(<span class="keyword">this</span>.dataStore[i])) &#123;</span><br><span class="line">        tempSet.add(<span class="keyword">this</span>.dataStore[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempSet;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.subset =  <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size() &gt; set.size()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.difference = difference;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> member <span class="keyword">in</span> <span class="keyword">this</span>.dataStore) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.contains(member)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.difference = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tempSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!set.contains(<span class="keyword">this</span>.dataStore[i])) &#123;</span><br><span class="line">        tempSet.add(<span class="keyword">this</span>.dataStore[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempSet;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><blockquote><p>树是一种非线性的数据结构，以分层的方式存储数据，被用来存储具有层级关系的数据和有序列表。二叉树是一种特殊的树，它的子节点不超过两个，使得它们之上的操作非常高效。</p></blockquote><p>二叉树有三种遍历方式：</p><ul><li>中序：升序访问所有的</li><li>先序：先访问根节点，再访问左节点和右节点</li><li>后序：先访问叶子节点，从左节点到右节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = data;</span><br><span class="line">  <span class="keyword">this</span>.left = left;</span><br><span class="line">  <span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BST</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="keyword">new</span> Node(data, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果二叉树是空的，就插入到根</span></span><br><span class="line">      <span class="keyword">this</span>.root = n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">      <span class="keyword">var</span> parent;</span><br><span class="line">      <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        parent = current;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; current.data) &#123;</span><br><span class="line">          <span class="comment">// 如果插入的值小，就插入到左边</span></span><br><span class="line">          current = current.left;</span><br><span class="line">          <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            parent.left = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果插入的值大，就插入到右边</span></span><br><span class="line">          current = current.right;</span><br><span class="line">          <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            parent.right = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 中序遍历</span></span><br><span class="line">  <span class="keyword">this</span>.inOrder = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 参数一般是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">      <span class="comment">// 先展示最左节点，然后到其父节点从左到右遍历，依次向上</span></span><br><span class="line">      inOrder(node.left);</span><br><span class="line">      node.show()</span><br><span class="line">      inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 先序遍历</span></span><br><span class="line">  <span class="keyword">this</span>.preOrder = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">      <span class="comment">// 先展示根节点，然后访问其左节点，到最左再访问其右节点</span></span><br><span class="line">      node.show()</span><br><span class="line">      preOrder(node.left);</span><br><span class="line">      preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 后序遍历</span></span><br><span class="line">  <span class="keyword">this</span>.postOrder = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">      <span class="comment">// 先展示最左节点，然后访问其父节点的右节点，再访问父节点</span></span><br><span class="line">      postOrder(node.left);</span><br><span class="line">      postOrder(node.right);</span><br><span class="line">      node.show()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.getMin = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span> (!(current.left == <span class="literal">null</span>)) &#123;</span><br><span class="line">      current = current.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.data</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.find = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span> (!(current.left == <span class="literal">null</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (current.data == data) &#123;</span><br><span class="line">        <span class="keyword">return</span> current</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; current.data) &#123;</span><br><span class="line">        current = current.left;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current = current.right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    root = removeNode(<span class="keyword">this</span>.root, data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.removeNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data == node.data) &#123;</span><br><span class="line">      <span class="comment">// 查找等于该节点，进行删除操作</span></span><br><span class="line">      <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 该节点没有子节点，直接放空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 该节点有右侧子节点，将右侧子节点连接至父节点</span></span><br><span class="line">        <span class="keyword">return</span> node.right</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 该节点有左侧子节点，将左侧子节点连接至父节点</span></span><br><span class="line">        <span class="keyword">return</span> node.left</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 该节点同时有左右两侧子节点，找该节点右侧最小值的节点，修改替换该节点值，再去删除这个节点</span></span><br><span class="line">      <span class="keyword">var</span> tempNode = getMin(node.right);</span><br><span class="line">      node.data = tempNode.data;</span><br><span class="line">      node.right = removeNode(node.right, tempNode.data);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; node.data) &#123;</span><br><span class="line">      <span class="comment">// 查找数据小于该节点，向左侧子节点搜索</span></span><br><span class="line">      node.left = <span class="keyword">this</span>.removeNode(node.left, data);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 查找数据大于该节点，向右侧子节点搜索</span></span><br><span class="line">      node.right = <span class="keyword">this</span>.removeNode(node.right, data);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><blockquote><p>图是由边的集合以及顶点的集合组成，分为有向图和无序图。<br>圈是至少有一条边，且第一个顶点和最后一个顶点相同的路径，没有重复边或者重复顶点的圈是简单圈，除了第一个和最后一个顶点以外，路径的其它顶点有重复的圈被称为平凡圈</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vertex</span>(<span class="params">label, vasVisited</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.label = label;<span class="comment">//顶点</span></span><br><span class="line">  <span class="keyword">this</span>.wasVisited = wasVisited;<span class="comment">//是否被访问过</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> temp</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> outer = arr.length; outer &gt; <span class="number">1</span>; --outer) &#123;</span><br><span class="line">    <span class="comment">//从末尾遍历到2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> inner = <span class="number">0</span>; inner &lt; outer; ++inner) &#123;</span><br><span class="line">      <span class="comment">//从0遍历outer-1</span></span><br><span class="line">      <span class="keyword">if</span> (arr[inner] &gt; arr[inner+<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// 01比较 12比较 23比较</span></span><br><span class="line">        <span class="comment">// 01 12</span></span><br><span class="line">        <span class="comment">// 01</span></span><br><span class="line">        temp = arr[inner]</span><br><span class="line">        arr[inner] = arr[inner+<span class="number">1</span>]</span><br><span class="line">        arr[inner+<span class="number">1</span>] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> min, temp</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> outer = <span class="number">0</span>; out &lt; arr.length - <span class="number">1</span>; ++outer) &#123;</span><br><span class="line">    <span class="comment">// 从0遍历到倒数第二个</span></span><br><span class="line">    min = outer</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> inner = outer+<span class="number">1</span>; inner &lt; arr.length ; ++inner) &#123;</span><br><span class="line">      <span class="comment">// 从outer+1（1开始）遍历到最后</span></span><br><span class="line">      <span class="keyword">if</span> (arr[inner] &lt; arr[min]) &#123;</span><br><span class="line">        min = inner</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 0到最后中最小的值交换到0，</span></span><br><span class="line">      <span class="comment">// 1到最后中最小的值交换到1，</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      temp = outer</span><br><span class="line">      outer = min</span><br><span class="line">      min = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> temp, inner</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> outer = <span class="number">1</span>; outer &lt; arr.length; ++outer) &#123;</span><br><span class="line">    <span class="comment">// 从第二个遍历到最后（一个个插入）</span></span><br><span class="line">    temp = arr[outer]</span><br><span class="line">    inner = outer</span><br><span class="line">    <span class="keyword">while</span> (inner &gt; <span class="number">0</span> &amp;&amp; arr[inner<span class="number">-1</span>] &gt;= temp) &#123;</span><br><span class="line">      <span class="comment">// 一个一个向前查找前面的元素，大于temp则右移，不大于则把temp换过去再停止</span></span><br><span class="line">      arr[inner] = arr[inner<span class="number">-1</span>]</span><br><span class="line">      --inner</span><br><span class="line">    &#125;</span><br><span class="line">    arr[inner] = temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><blockquote><p>适用于大型数据集合，小数据性能反而下降</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> left = []</span><br><span class="line">  <span class="keyword">var</span> right = []</span><br><span class="line">  <span class="keyword">var</span> pivot = arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">      left.push(arr[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> qSort(left).concat(pivot, qSort(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h4><p>顺序查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seqSearch</span>(<span class="params">arr, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;arr.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] === data) &#123;</span><br><span class="line">      swap(arr[i], arr[i<span class="number">-1</span>])<span class="comment">// 自组织</span></span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找</p><blockquote><p>相比顺序查找，二分查找算法比顺序查找更高效。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binSearch</span> (<span class="params">arr, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> upperBound = arr.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> lowerBound = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (lowerBound &lt;= upperBound) &#123;</span><br><span class="line">    <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor((upperBound + lowerBound) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; data) &#123;</span><br><span class="line">      lowerBound = mid + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; data) &#123;</span><br><span class="line">      upperBound = mid - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mid</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><blockquote><p>动态规划从问题的底部开始解决（与递归相反），把小问题解决合并成一个整体解决方案</p></blockquote><p>得到斐波那契数列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recurFib</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n&lt;<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> recurFib(n<span class="number">-1</span>) + recurFib(n<span class="number">-2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">// 效率很差，没有保存之前的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dynFib</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> last = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> nextLast = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    result = last + nextLast</span><br><span class="line">    nextLast = last</span><br><span class="line">    last = result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;<span class="comment">// 更强</span></span><br></pre></td></tr></table></figure><p>背包问题</p><p>```javascript<br>// 递归方式<br>function knapsack (capacity, size, value, n) {<br>  // 容量，大小arr，价值arr，数量<br>  // 递归方式<br>  if (n == 0 || capacity == 0) {<br>    return 0<br>  }<br>  if (size[n-1] &gt; capacity) {<br>    // 装不下就找下一个<br>    return knapsack(capacity, size, value, n - 1)<br>  } else {<br>    // 装得下就比较大小看看装不装<br>    return Math.max(<br>      value[n - 1] + knapsack(capacity - size[n - 1], size, value, n - 1),<br>      knapsack(capacity, size, value, n - 1)<br>    )<br>  }<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; href=&quot;/owl.css&quot;&gt;&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h2&gt;&lt;h4 id=&quot;数组-Array&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="Javascript" scheme="http://lumpychen.github.io/tags/Javascript/"/>
    
      <category term="Basic" scheme="http://lumpychen.github.io/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础总结</title>
    <link href="http://lumpychen.github.io/2017/zh-cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <id>http://lumpychen.github.io/2017/zh-cn/数据库基础总结/</id>
    <published>2017-09-09T16:40:59.000Z</published>
    <updated>2017-09-11T14:43:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p>把之前学过的<code>SQL</code>的知识复习一遍，记一下难点。</p><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>数值类型 <code>INT</code>、<code>FLOAT</code></li><li>字符串类型 <code>CHAR</code>、<code>TEXT</code></li><li>日期和时间类型 <code>DATE</code>、<code>TIMESTAMP</code></li><li>复合类型 <code>ENUM</code>、<code>SET</code></li></ul><p>其中一个<code>ENUM</code>类型只允许从一个集合中取得一个值；而<code>SET</code>类型允许从一个集合（元素不能重复的）中取得任意多个值</p><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><ul><li>任意两行都不具有相同的主键值</li><li>每一行都必须具有一个主键值（主键列不允许<code>NULL</code>值），虽然不一定需要</li><li>主键列中的值不允许修改或更新</li><li>主键值不能重用(如果某行从表中删除，它的主键不能赋给以后的新行)。</li></ul><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><h4 id="命令排序"><a href="#命令排序" class="headerlink" title="命令排序"></a>命令排序</h4><ol><li>SELECT 要返回的列或表达式</li><li>FROM 从中检索数据的表</li><li>WHERE 行级过滤</li><li>GROUP BY 分组说明</li><li>HAVING 组级过滤</li><li>ORDER BY 输出排序顺序</li></ol><h4 id="不同的值"><a href="#不同的值" class="headerlink" title="不同的值"></a>不同的值</h4><p><code>DISTINCT</code></p><p>返回所有学生的年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> age</span><br><span class="line"><span class="keyword">FROM</span> student</span><br></pre></td></tr></table></figure><h4 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h4><p>检索记录行 6、7、8</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> age</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">5</span> <span class="keyword">offset</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>检索前 5 个记录行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> age</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h4><p><code>ORDER BY</code></p><p>按照排列对象二进制的编码从小到大排序</p><blockquote><p>Comparing the ASCII one by one until difference found, or, one reach the end of the string, it’s the same logic in other program languages.</p></blockquote><p><code>DESC</code>倒序</p><p>从贵到便宜排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> age</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h4 id="与或"><a href="#与或" class="headerlink" title="与或"></a>与或</h4><p><code>SQL</code>先处理<code>AND</code>在处理<code>OR</code></p><h4 id="HAVING-和-WHERE"><a href="#HAVING-和-WHERE" class="headerlink" title="HAVING 和 WHERE"></a>HAVING 和 WHERE</h4><p><code>WHERE</code>过滤行、<code>HAVING</code>过滤分组<br><code>WHERE</code>在数据分组前进行过滤，<code>HAVING</code>在数据分组后进行过滤<br><code>WHERE</code>排除的行不包括在分组中，这可能会改变<code>HAVING</code>子句中基于这些值过滤掉的分组</p><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>可以把一条<code>SELECT</code>语句返回的结果用于另一条<code>SELECT</code>语句的<code>WHERE</code>子句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">                    <span class="keyword">FROM</span> OrderItems</span><br><span class="line">                    <span class="keyword">WHERE</span> prod_id = <span class="string">'RGAN01'</span>)</span><br></pre></td></tr></table></figure><p>在SELECT语句中，子查询总是从内向外处理</p><p>作为子查询的SELECT语句只能查询单个列，企图检索多个列将返回错误</p><h4 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h4><p>查询一个顾客的订单数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="string">'1000000001'</span></span><br></pre></td></tr></table></figure><p>查询所有顾客的订单数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,</span><br><span class="line">cust_state,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> Orders.cust_id = Customers.cust_id) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure><h4 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h4><p>如果数据存储在多个表中，怎样用一条<code>SELECT</code>语句就检索出数据呢？答案是使用联结：</p><ul><li>内联结</li><li>外联结</li><li>交叉联结</li></ul><p>假设有以下两个表，其中<code>a.id</code>同<code>b.parent_id</code>存在关系：</p><p>A表</p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">name</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">张三</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">李四</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">王五</td></tr></tbody></table><p>B表</p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">job</th><th style="text-align:center">paremt</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">23</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">34</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">34</td><td style="text-align:center">4</td></tr></tbody></table><ul><li>内联结根据每个表<strong>共有的列</strong>的值匹配两个表中的行</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.*,b.* <span class="keyword">FROM</span> a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> b <span class="keyword">on</span> a.id=b.parent_id</span><br></pre></td></tr></table></figure><p>返回结果：</p><blockquote><p>1   张三                 1     23     1<br>2   李四                 2     34     2   </p></blockquote><ul><li>左向外连接的结果集包括指定的左表的所有行，如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.*,b.* <span class="keyword">FROM</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b <span class="keyword">on</span> a.id=b.parent_id</span><br></pre></td></tr></table></figure><p>返回结果：</p><blockquote><p>1   张三                  1     23     1<br>2   李四                  2     34     2<br>3   王五                  null</p></blockquote><ul><li>右向外连接的结果集包括指定的右表的所有行，如果左表的某行在右表中没有匹配行，则将为左表返回空值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.*,b.* <span class="keyword">FROM</span> a <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> b <span class="keyword">on</span> a.id=b.parent_id</span><br></pre></td></tr></table></figure><p>返回结果：</p><p>1   张三                  1     23     1<br>2   李四                  2     34     2<br>  null                   3     34     4  </p><ul><li>完整外部连接返回左表和右表中的所有行</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.*,b.* <span class="keyword">FROM</span> a <span class="keyword">FULL</span> <span class="keyword">JOIN</span> b <span class="keyword">on</span> a.id=b.parent_id</span><br></pre></td></tr></table></figure><p>返回结果：</p><blockquote><p>1   张三                 1     23     1<br>2   李四                 2     34     2<br>  null               　　3     34     4<br>3   王五                 null</p></blockquote><ul><li>交叉联结，两个表的数据进行组合</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.*,b.* <span class="keyword">FROM</span> a <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> b</span><br></pre></td></tr></table></figure><p>返回<code>3*3=9</code>条数据</p><ul><li>自联结，一个表出现多次</li></ul><h4 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h4><p>可用<code>UNION</code>操作符来组合数条<code>SQL</code>查询。利用<code>UNION</code>，可给出多条<code>SELECT</code>语句，将它们的结果组合成一个结果集（不能重复）</p><p>如果需要重复，使用<code>UNION ALL</code></p><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><h4 id="正常添加行"><a href="#正常添加行" class="headerlink" title="正常添加行"></a>正常添加行</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'10001'</span>, <span class="string">'TONY'</span>)</span><br></pre></td></tr></table></figure><h4 id="移植多行"><a href="#移植多行" class="headerlink" title="移植多行"></a>移植多行</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id,</span><br><span class="line">                      cust_email,</span><br><span class="line">                      cust_name,</span><br><span class="line">                      cust_address,</span><br><span class="line">                      cust_city,</span><br><span class="line">                      cust_state,</span><br><span class="line">                      cust_zip,</span><br><span class="line">                      cust_country)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cust_id,</span><br><span class="line">cust_contact,</span><br><span class="line">cust_email,</span><br><span class="line">cust_name,</span><br><span class="line">cust_address,</span><br><span class="line">cust_city,</span><br><span class="line">cust_state,</span><br><span class="line">cust_zip,</span><br><span class="line">cust_country</span><br><span class="line">cust_contact,</span><br><span class="line">cust_email,</span><br><span class="line">cust_name,</span><br><span class="line">cust_address,</span><br><span class="line">cust_city,</span><br><span class="line">cust_state,</span><br><span class="line">cust_zip,</span><br><span class="line">cust_country)</span><br><span class="line"><span class="keyword">FROM</span> CustNew;</span><br></pre></td></tr></table></figure><h4 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">INTO</span> CustCopy</span><br><span class="line"><span class="keyword">FROM</span> Customers;</span><br></pre></td></tr></table></figure><h2 id="UPDATE-amp-DELETE"><a href="#UPDATE-amp-DELETE" class="headerlink" title="UPDATE &amp; DELETE"></a>UPDATE &amp; DELETE</h2><h4 id="正常更新行"><a href="#正常更新行" class="headerlink" title="正常更新行"></a>正常更新行</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Customers</span><br><span class="line"><span class="keyword">SET</span> cust_contact = <span class="string">'Sam Roberts'</span>,</span><br><span class="line">  cust_email = <span class="string">'sam@toyland.com'</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="string">'1000000006'</span>;</span><br></pre></td></tr></table></figure><h4 id="正常删除表"><a href="#正常删除表" class="headerlink" title="正常删除表"></a>正常删除表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="string">'1000000006'</span></span><br></pre></td></tr></table></figure><p>使用外键的好处是防止删除某个关系需要用到的行：<br>例如，要从<code>Products</code>表中删除一个产品，而这个产品用在<code>OrderItems</code>的已有订单中，那么DELETE语句将抛出错误并中止</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><h2 id="管理事务"><a href="#管理事务" class="headerlink" title="管理事务"></a>管理事务</h2><ol><li>检查数据库中是否存在相应的顾客，如果不存在，添加他;</li><li>提交顾客信息;</li><li>检索顾客的<code>ID</code>;</li><li>在<code>Orders</code>表中添加一行;</li><li>如果向<code>Orders</code>表添加行时出现故障，回退;</li><li>检索<code>Orders</code>表中赋予的新订单<code>ID</code>;</li><li>对于订购的每项物品，添加新行到<code>OrderItems</code>表;</li><li>如果向<code>OrderItems</code>添加行时出现故障，回退所有添加的<code>OrderItems</code>行和<code>Orders</code>行</li></ol><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul><li>主键<code>PRIMARY KEY</code></li><li>外键<code>REFERENCES XX(XX)</code></li><li>唯一约束<code>UNIQUE</code></li><li>检查约束<code>CHECK(xx &gt; xx)</code></li></ul><h4 id="唯一约束和主键的区别"><a href="#唯一约束和主键的区别" class="headerlink" title="唯一约束和主键的区别"></a>唯一约束和主键的区别</h4><ul><li>表可包含多个唯一约束，但每个表只允许一个主键。</li><li>唯一约束列可包含<code>NULL</code>值。</li><li>唯一约束列可修改或更新。</li><li>唯一约束列的值可重复使用。</li><li>与主键不一样，唯一约束不能用来定义外键。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li>索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。在执行这些操作时，DBMS必须动态地更新索引。</li><li>索引数据可能要占用大量的存储空间。 并非所有数据都适合做索引。取值不多的数据(如州)不如具有更多可能值的数据(如姓或名)，能通过索引得到那么多的好处。</li><li>索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能适合做索引。</li><li>可以在索引中定义多个列(例如，州加上城市)。这样的索引仅在以州加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处。</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>对数据库管理功能(创建表、更改或删除已存在的表等)的访问;</li><li>对特定数据库或表的访问;</li><li>访问的类型(只读、对特定列的访问等);</li><li>仅通过视图或存储过程对表进行访问;</li><li>创建多层次的安全措施，从而允许多种基于登录的访问和控制;</li><li>限制管理用户账号的能力。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把之前学过的&lt;code&gt;SQL&lt;/code&gt;的知识复习一遍，记一下难点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="basic" scheme="http://lumpychen.github.io/tags/basic/"/>
    
      <category term="mysql" scheme="http://lumpychen.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>认证授权</title>
    <link href="http://lumpychen.github.io/2017/zh-cn/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/"/>
    <id>http://lumpychen.github.io/2017/zh-cn/认证授权/</id>
    <published>2017-08-23T18:31:42.000Z</published>
    <updated>2017-10-07T06:29:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p><code>HTTP</code>的一个最大的特点就是它是<strong>无状态协议</strong> —— 客户端发一次请求给服务器，走一个请求和响应的循环之后，服务器就立刻忘记可客户端，同一个客户端再次访问服务器的时候，服务器就不认识这个客户端了</p><p>客户端和服务器之间是不能保持一种“链接状态”的，所以说<code>HTTP</code>是一个无状态协议</p><p>为了实现用户登录的一种状态，实现认证和授权，我们该怎么做呢？</p><a id="more"></a><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><code>cookie</code>是客户端浏览器上的专属于某个域名的一个小文件，用于服务端确认客户端</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>客户端：浏览器每次发出请求的时候都会携带着<code>cookie</code>信息在<code>HTTP</code>的头信息里给服务器</p><p>服务器端：<code>cookie</code>一般都是在服务器端设置的，通过<code>HTTP</code>响应的头部：<code>Set-Cookie</code>返回给浏览器，浏览器拿到这些数据就可以保存到自己的<code>cookie</code>文件中</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>每个域名最多只能有20条<code>cookie</code>，长度不能超过4KB</li><li>安全性问题。如果<code>cookie</code>被人拦截了，那人转发就可以取得所有的会话权限</li><li>浪费带宽</li><li>不可以跨域调用</li></ul><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><code>session</code>的含义是“会话”（或者也叫对话，<code>session</code>的本意是“一段时间”）,</p><h4 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h4><p>每次有一个新的浏览器用户登录进来，服务器端都会创建一个新的<code>session</code>，那么在这个<code>session</code>之中，服务器就可以为这位特定用户（其实就是为特定的那个浏览器）保存任意信息了</p><h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>但是同一时刻，连接到服务器的浏览器可能成千上万，那么服务器是如何区分不同用户的浏览器的呢？</p><p>“使用<code>cookie</code>”</p><p>具体来说，每个服务器端的 session 被创建的时候，都会有一个<code>sessionId</code></p><p>被创建的时<code>sessionId</code>都会自动的被发送到浏览器的<code>cookie</code>中，这样，每个浏览器就跟自己在服务器上的<code>session</code>有了绑定关系了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;HTTP&lt;/code&gt;的一个最大的特点就是它是&lt;strong&gt;无状态协议&lt;/strong&gt; —— 客户端发一次请求给服务器，走一个请求和响应的循环之后，服务器就立刻忘记可客户端，同一个客户端再次访问服务器的时候，服务器就不认识这个客户端了&lt;/p&gt;
&lt;p&gt;客户端和服务器之间是不能保持一种“链接状态”的，所以说&lt;code&gt;HTTP&lt;/code&gt;是一个无状态协议&lt;/p&gt;
&lt;p&gt;为了实现用户登录的一种状态，实现认证和授权，我们该怎么做呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="develop" scheme="http://lumpychen.github.io/tags/develop/"/>
    
  </entry>
  
  <entry>
    <title>Cleaverjs简介</title>
    <link href="http://lumpychen.github.io/2016/zh-cn/Cleaverjs%E7%AE%80%E4%BB%8B/"/>
    <id>http://lumpychen.github.io/2016/zh-cn/Cleaverjs简介/</id>
    <published>2016-10-18T13:29:19.000Z</published>
    <updated>2017-10-07T05:08:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p>本片博客为大家带来<code>Cleaver.js</code>的指南</p><p>幻灯片版本的介绍<a href="https://lumpychen.github.io/cleaver_intro/">点这里浏览</a></p><a id="more"></a><p>–</p><h2 id="Cleaver是什么？"><a href="#Cleaver是什么？" class="headerlink" title="Cleaver是什么？"></a>Cleaver是什么？</h2><p>Cleaver 是一个能根据一个 Markdown 文档<strong>快速生成简易 PPT</strong> 的 强大工具</p><blockquote><p>如果你已经有了一个 Markdown 的文档，30秒就可以制作成幻灯片。</p></blockquote><p><a href="https://github.com/jdan/cleaver" target="_blank" rel="noopener">Github戳这里</a></p><p>–</p><h2 id="厌倦了PPT？"><a href="#厌倦了PPT？" class="headerlink" title="厌倦了PPT？"></a>厌倦了PPT？</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://b-i.forbesimg.com/carminegallo/files/2013/11/6845.strip_.zoom_-e1385136828745.gif" alt=""></h2><h2 id="它的优势之处在于："><a href="#它的优势之处在于：" class="headerlink" title="它的优势之处在于："></a>它的优势之处在于：</h2><ol><li>简易而快速</li><li>如果你会用 Markdown ，你不需要额外学习</li><li>生成静态网页，易于在线分享</li><li>移动端同样易于浏览</li></ol><p>–</p><h2 id="使用Cleaver，你需要："><a href="#使用Cleaver，你需要：" class="headerlink" title="使用Cleaver，你需要："></a>使用Cleaver，你需要：</h2><ul><li>Cleaver 基于 HTML5，你需要现代的浏览器</li><li>Cleaver 需要 nodejs 的环境</li><li>使用 Cleaver 需要掌握 Markdown 的语法</li></ul><p>–</p><h2 id="安装Cleaver"><a href="#安装Cleaver" class="headerlink" title="安装Cleaver"></a>安装Cleaver</h2><ol><li>下载并安装 <a href="https://nodejs.org/download/" target="_blank" rel="noopener">node.js</a> （如果需要）</li><li>终端里执行以下代码：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install cleaver -g</span><br></pre></td></tr></table></figure><p>等待其安装成功即可</p><p>–</p><h2 id="使用Cleaver"><a href="#使用Cleaver" class="headerlink" title="使用Cleaver"></a>使用Cleaver</h2><p> Cleaver 和普通的 Markdown 存在一点区别：</p><ol><li>需要在 Markdown 文件开头添加少量配置，<a href="https://github.com/jdan/cleaver/blob/master/docs/options.md" target="_blank" rel="noopener">配置的API</a></li><li><p>需要在正文中使用<code>--</code>来进行幻灯片的分页</p><p>比如这个幻灯片对应的 markdown 文件<a href="https://raw.githubusercontent.com/LumpyChen/cleaver_intro/master/cleaver_demo.md" target="_blank" rel="noopener">源码在此</a></p><p>–</p><h2 id="常用配置详解"><a href="#常用配置详解" class="headerlink" title="常用配置详解"></a>常用配置详解</h2></li></ol><table><thead><tr><th style="text-align:center">配置名</th><th style="text-align:center">默认值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">title</td><td style="text-align:center">-</td><td style="text-align:center">页面的总标题</td></tr><tr><td style="text-align:center">author</td><td style="text-align:center">-</td><td style="text-align:center">作者信息（需详细配置）</td></tr><tr><td style="text-align:center">theme</td><td style="text-align:center">jdan/cleaver-retro</td><td style="text-align:center">采用主题样式</td></tr><tr><td style="text-align:center">output</td><td style="text-align:center">basic.html</td><td style="text-align:center">生成的文件</td></tr><tr><td style="text-align:center">controls</td><td style="text-align:center">true</td><td style="text-align:center">是否显示控制按钮</td></tr></tbody></table><p> –</p><h2 id="生成PPT效果的HTML"><a href="#生成PPT效果的HTML" class="headerlink" title="生成PPT效果的HTML"></a>生成PPT效果的HTML</h2><p> 安装完 cleaver 之后，我们可以来使用它<br> 在终端里面执行：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleaver [你的markdown文件]</span><br></pre></td></tr></table></figure><p> 你就会得到你生成的 html 文件了</p><p> –</p><h2 id="主题样式"><a href="#主题样式" class="headerlink" title="主题样式"></a>主题样式</h2><p>  Cleaver 有<a href="https://github.com/jdan/cleaver/wiki/Theme-Inde://github.com/jdan/cleaver/wiki/Theme-Index" target="_blank" rel="noopener">很多主题</a>可供选择：</p><ul><li>jdan/cleaver-retro</li><li>iamstarkov/cleaver-ribbon</li><li>sudodoki/reveal-cleaver-theme</li><li>sjaakvandenberg/cleaver-dark</li><li>sjaakvandenberg/cleaver-light</li><li><p>select/cleaver-select-theme</p><p>个人推荐最后一个</p><p>–</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>幻灯片最后一页是自动生成的，会展示作者介绍</p><p>Cleaver 仍然还有一点排版上的问题，当然你可以贡献源码</p><p>总而言之，如果你需要进行不是一项特别复杂的汇报展示时，我们可以使用 Cleaver 代替 PowerPoint</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本片博客为大家带来&lt;code&gt;Cleaver.js&lt;/code&gt;的指南&lt;/p&gt;
&lt;p&gt;幻灯片版本的介绍&lt;a href=&quot;https://lumpychen.github.io/cleaver_intro/&quot;&gt;点这里浏览&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="tool" scheme="http://lumpychen.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>Javascript异步探讨</title>
    <link href="http://lumpychen.github.io/2016/zh-cn/Javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://lumpychen.github.io/2016/zh-cn/Javascript异步编程/</id>
    <published>2016-10-17T10:17:02.000Z</published>
    <updated>2017-10-07T05:10:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p>在图形用户界面编程中（也被称为<code>GUI</code>编程），用单一线程进行<code>GUI</code>控制是通常的做法</p><p>如果使用多线程来进行<code>GUI</code>编程，例如，一个线程修改某个<code>UI</code>模块的属性，另一个线程直接删除这个<code>UI</code>模块，那么<code>UI</code>的表现将很难被预测</p><p><code>Javascript</code>运行的环境是<code>单线程</code>的：每一个<code>window</code>或者一个<code>node.js</code>程序只有一个线程</p><p>因此，在<code>JS</code>程序正在执行的某个时间，只有特定的某个语句正在执行（此时其它的语句会被阻塞）</p><p>我个人很喜欢知乎上面<a href="https://www.zhihu.com/question/31982417/answer/54136684" target="_blank" rel="noopener">@云澹的回答</a></p><blockquote><p>运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。而浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。javascript引擎是单线程处理它的任务队列。所以当多个事件触发时，会依次放入队列，然后一个一个响应。</p><footer><strong>@云澹</strong></footer></blockquote><a id="more"></a><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>在<code>Javascript</code>的主线程中，我们有一个<code>堆(heap)</code>和<code>栈(stack)</code>的结构：</p><p><img src="http://image.slidesharecdn.com/sonlejs-event-loop-160805060652/95/javascript-event-loop-11-638.jpg?cb=1470377352" alt="heap&amp;stack"></p><p>其中：</p><ul><li>堆的结构负责内存的分配</li><li>栈的结构负责线程中要执行的内容，被称为<code>访问栈(call stack)</code></li></ul><p>我们可以看看<code>访问栈</code>的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printDouble</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = bar(c)</span><br><span class="line">  <span class="built_in">console</span>.log(sum)</span><br><span class="line">&#125;</span><br><span class="line">printDouble(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>在执行的过程中，我们的<code>访问栈</code>发生以下的变化：</p><ol><li>主线程进栈</li><li><code>printDouble</code>进栈</li><li><code>bar</code>进栈</li><li><code>foo</code>进栈</li><li><code>foo</code>出栈</li><li><code>bar</code>出栈</li><li><code>console.log</code>进栈</li><li><code>console.log</code>出栈</li><li><code>printDouble</code>出栈</li><li>主线程出栈</li></ol><p>如果我们在<code>foo</code>函数中发生了错误，我们会得到报错信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Uncaught Error: 发生了错误(…)  VM1436:1</span><br><span class="line">  foo @ VM14136:1</span><br><span class="line">  bar @ VM14205:1</span><br><span class="line">  printDouble @ VM14298:1</span><br><span class="line">  (anonymous function) @ VM14324:1</span><br></pre></td></tr></table></figure><p>我们得到从上到下的结果就是所谓的<code>访问栈</code></p><p>当我们得到了<code>RangeError: maximum call stack size exceeded</code>的报错信息时，就代表我们的访问栈的大小不够了，去检查你的程序中有没有进行无限循环调用的语句吧 : )</p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>因为<code>Javascript</code>是单线程，一个<code>Javascript</code>程序只有一个<code>访问栈</code>，函数语句按照进入的顺序一个接一个地被执行，前一个结束，才轮到后一个开始</p><p>然而有的时候，某些函数语句的主要时间消耗并不在<code>CPU</code>上，而是在输入输出设备（包括网络）上面，比如<code>Ajax</code>，这样的任务消耗了很多时间，从而阻塞了后续任务的执行，同时也浪费了<code>CPU</code>的资源</p><p>单线程任务同步执行的优势就是清晰易于理解，其缺陷就是经常会出现这种情况</p><p>为了解决这个问题，我们把要执行的任务分为两种：<code>同步(synchronous)</code>和<code>异步(asynchronous)</code></p><ul><li><code>同步任务</code>就是一般情况下的语句 —— 只有执行完毕之后才会执行后面的语句</li><li><code>异步任务</code>则是特殊的语句 —— 先执行特定的语句引发异步操作：调用相关接口，然后等待其他的部分的运转，等时机成熟再执行与运转结果相关的事件</li></ul><p>比如我们比较一下采用同步和异步的方式来执行<code>Ajax</code>：</p><ul><li>同步执行时，我们调用<code>Ajax</code>的接口，根据地址发起请求，直到响应返回，才执行接下来的任务</li><li>异步执行时，我们调用<code>Ajax</code>的接口请求相应地址，然后执行接下来的任务，当响应返回时，特定的函数语句会被加入到<code>访问栈</code></li></ul><p>更加明显的例子当我们使用<code>node.js</code>时，我们会发现很多函数会有同步异步两个版本，比如<code>readFile</code>和<code>readFileSync</code></p><ul><li>当你使用<code>readFile</code>时，最后一个参数为<code>回调函数</code>，响应返回时会被异步执行</li><li>当你使用<code>readFileSync</code>时，下一个语句一定是在<code>readFileSync</code>的文件操作结束返回结果后进行的</li></ul><h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>以下几类任务被当做异步任务：</p><ul><li><code>DOM</code>事件监听</li><li><code>XMLHttpRequest</code></li><li><code>setTimeout</code> &amp; <code>setInterval</code></li></ul><p>注意，<code>DOM</code>事件监听 – <code>addEventListener</code>函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数，事件触发时，表示异步任务完成，会将事件监听器函数封装成一个任务放到<code>任务队列</code>中，等待主线程执行，事件冒泡时，多条任务按照事件冒泡的顺序进入<code>任务队列</code></p><p>而<code>onclick</code>,<code>onchange</code>等的<code>handler</code>函数也是异步执行的，同理</p><p>异步任务伴随着<code>回调函数</code> —— 在任务时机成熟时执行的函数，<code>回调函数</code>是异步调用，也就是所谓事件驱动的</p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p><code>Javascript</code>线程中有一个<code>任务队列</code>：保存着等待执行的异步任务的队列</p><p>观察一下所谓的<code>事件队列的模型</code>：</p><p><img src="http://images.cnitblog.com/blog2015/221923/201503/171756342043920.png" alt="模型"></p><p>我们举个关于<code>setTimeout</code>的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Timeout!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end!'</span>)</span><br></pre></td></tr></table></figure><ol><li>主线程进栈</li><li><code>setTimeout</code>进栈</li><li>调用<code>setTimeout</code>的<code>API</code>，设置一个定时器，5秒钟之后<code>回调函数</code>加入<code>任务队列</code></li><li><code>setTimeout</code>出栈</li><li><code>console.log(&#39;end!&#39;)</code>进栈</li><li><code>console.log(&#39;end!&#39;)</code>出栈</li><li>主线程出栈</li><li>事件轮询，任务队列中的匿名函数进栈</li><li><code>console.log(&#39;Timeout!&#39;)</code>进栈</li><li><code>console.log(&#39;Timeout!&#39;)</code>出栈</li><li>匿名函数出栈</li></ol><p>每当<code>访问栈</code>空的时候，栈会执行<code>事件轮询</code>操作，从<code>任务队列</code>里面读取任务并执行</p><p>所以，异步过程的<code>回调函数</code>，一定不在当前这一轮事件循环中执行</p><h2 id="单线程和异步"><a href="#单线程和异步" class="headerlink" title="单线程和异步"></a>单线程和异步</h2><p>所以像<code>setTimeout</code>这样的异步任务不一定会准确执行</p><p>我们先看一下回答中的代码段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"first"</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'second'</span>)</span><br><span class="line">  &#125;,<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果为：first*1000000, second*1000000</span></span><br></pre></td></tr></table></figure><p>按照我们正常的思维，我们执行1000000次<code>foo</code>函数，每执行一次都会设置一个五毫秒的定时器，然后<code>console.log</code>出<code>&quot;second&quot;</code>，但是我们发现控制台在几秒内一直在重复弹出<code>&quot;first&quot;</code>（这段时间远大于五毫秒），并没有<code>second</code>在这段时间弹出，直到所有<code>first</code>全部弹出完毕</p><p>现在我们能理解这个问题了，只有<code>访问栈</code>里面的任务全部推出之后，<code>任务队列</code>里面的<code>回调函数</code>才会开始执行，所以在<code>first</code>没有完成输出之前，异步调用的<code>second</code>不会执行</p><p>我们同时可以理解<code>foo()</code>和<code>setTimeout(foo,0)</code>的具体区别了</p><h2 id="在React出现的一点点问题"><a href="#在React出现的一点点问题" class="headerlink" title="在React出现的一点点问题"></a>在React出现的一点点问题</h2><p>在<code>React</code>中，<code>setState</code>函数是异步执行的，如果你在<code>Component</code>的方法里面先调用<code>setState</code>再调用<code>this.state</code>，你会发现后面<code>this.state</code>得到的值与前面<code>setState</code>设置的值不一样，得到的仍然是<code>setState</code>之前的值</p><p>看完前面的分析，我想这并不那么难以理解了：<code>setState</code>会进入<code>任务队列</code>，直到<code>访问栈</code>被清空，才会执行<code>事件轮询</code>，从而执行<code>任务队列</code>中的任务</p><p>我在<code>React</code>的开发中遇到过如下的问题：</p><p><a href="http://stackoverflow.com/questions/28922275/in-reactjs-why-does-setstate-behave-differently-when-called-synchronously" target="_blank" rel="noopener">这个问题</a>讲述了同步/异步调用<code>setState</code>的区别</p><p><a href="http://jsbin.com/dawezapoga/edit?js,console,output" target="_blank" rel="noopener">这个jsbin</a>上面存在相关的实例：</p><p><code>Setting value</code>代表<code>render</code>时<code>State</code>里面的内容<br><code>Current value</code>代表<code>render</code>时，用<code>getDOMNode</code>得到的<code>DOM</code>里面的属性</p><div class="tip"><br>注意：这是一个<a href="https://facebook.github.io/react/docs/forms.html#controlled-components" target="_blank" rel="noopener">Controlled Components</a>，会忽视用户对<code>input.value</code>在<code>DOM</code>上的改变，但<code>e.target.value</code>的值是用户在<code>input</code>上改变后的值<br></div><p>我把 @FakeRainBrigand 的答案 以及自己的理解，进行了结合，得到了下面的过程</p><p>同步调用：</p><ol><li>输入<code>X</code>到<code>input</code>标签里面</li><li><code>input.value</code>不变，触发<code>onchange</code>事件</li><li>执行事件处理函数<code>onchange</code></li><li>执行<code>setState({value: &#39;HelXlo&#39;})</code></li><li>进行虚拟<code>DOM</code>的<code>Diff</code>操作，识别出<code>input.value</code>应该是<code>&#39;HelXlo&#39;</code>，将<code>DOM</code>操作加入<code>任务队列</code></li><li><code>onchange</code>任务结束，将<code>render</code>加入<code>任务队列</code></li><li>执行<code>事件轮询</code>，依次执行<code>DOM</code>操作与<code>render</code><ul><li><code>DOM</code>操作将<code>input.value</code>改为当前<code>state</code>的值<code>为&#39;HelXlo&#39;</code></li><li><code>render</code>，此时<code>state</code>里面<code>value</code>和<code>DOM</code>里面<code>input.value</code>都是<code>&#39;HelXlo&#39;</code></li></ul></li></ol><p>异步调用：</p><ol><li>输入<code>X</code>到<code>input</code>标签里面</li><li><code>input.value</code>不变，触发<code>onchange</code>事件</li><li>执行事件处理函数<code>onchange</code>，将<code>setState</code>的定时器加入<code>任务队列</code></li><li><code>onchange</code>任务结束，将<code>render</code>加入<code>任务队列</code></li><li>进行<code>事件轮询</code>，执行了<code>任务队列</code>中的定时器，执行<code>setState</code></li><li>执行<code>setState({value: &#39;HelXlo&#39;})</code></li><li>进行虚拟<code>DOM</code>的<code>Diff</code>操作，识别出<code>input.value</code>应该是’Hello’<code>，将</code>DOM<code>操作加入</code>任务队列`</li><li><code>render</code>，此时<code>state</code>里面<code>value</code>为<code>&#39;HelXlo&#39;</code>，但<code>DOM</code>上<code>input.value</code>为<code>&#39;Hello&#39;</code></li><li>执行<code>任务队列</code>后面的任务，进行DOM操作，改变<code>input.value</code>为<code>&#39;HelXlo&#39;</code>（此时<code>DOM</code>更新令光标被置于<code>input</code>末尾）</li></ol><div class="tip"><br>有一点小小的 <strong>魔法</strong>： <code>React</code>会在<code>onchange</code>这种<code>事件处理函数</code>后异步调用<code>render</code>方法（而<code>DOM</code>操作也是异步执行的，别忘了）<br></div><p>通过各种猜想和实验，我得到了上面的结果</p><p>我不确认自己的想法是对的，所以这篇博客先放在这里，等我对源码有了更深的理解在回来证实和修改</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在图形用户界面编程中（也被称为&lt;code&gt;GUI&lt;/code&gt;编程），用单一线程进行&lt;code&gt;GUI&lt;/code&gt;控制是通常的做法&lt;/p&gt;
&lt;p&gt;如果使用多线程来进行&lt;code&gt;GUI&lt;/code&gt;编程，例如，一个线程修改某个&lt;code&gt;UI&lt;/code&gt;模块的属性，另一个线程直接删除这个&lt;code&gt;UI&lt;/code&gt;模块，那么&lt;code&gt;UI&lt;/code&gt;的表现将很难被预测&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Javascript&lt;/code&gt;运行的环境是&lt;code&gt;单线程&lt;/code&gt;的：每一个&lt;code&gt;window&lt;/code&gt;或者一个&lt;code&gt;node.js&lt;/code&gt;程序只有一个线程&lt;/p&gt;
&lt;p&gt;因此，在&lt;code&gt;JS&lt;/code&gt;程序正在执行的某个时间，只有特定的某个语句正在执行（此时其它的语句会被阻塞）&lt;/p&gt;
&lt;p&gt;我个人很喜欢知乎上面&lt;a href=&quot;https://www.zhihu.com/question/31982417/answer/54136684&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@云澹的回答&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。而浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。javascript引擎是单线程处理它的任务队列。所以当多个事件触发时，会依次放入队列，然后一个一个响应。&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;@云澹&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://lumpychen.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS正则表达式快速入门</title>
    <link href="http://lumpychen.github.io/2016/zh-cn/Javascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://lumpychen.github.io/2016/zh-cn/Javascript正则表达式快速入门/</id>
    <published>2016-09-26T02:26:09.000Z</published>
    <updated>2017-09-11T14:52:35.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p>我们都爱正则表达式，但是一个个奇怪字符的组合总是让我这种弱鸡感到难以领悟。</p><p>每次看到一个正则匹配式却理解不了，我都安慰自己：“反正我已经知道它是用来匹配文本的”</p><p>为什么不现在直接把它学会呢？</p><a id="more"></a><hr><p>首先推一个可以帮助你理解正则的网站<a href="https://regexper.com" target="_blank" rel="noopener">正则表达式可视化</a></p><p>还有一个 Atom 插件 <a href="https://atom.io/packages/regex-railroad-diagram" target="_blank" rel="noopener">regex-railroad-diagram</a></p><p>这样的可视化模型可以帮助你快速回忆与熟悉正则字符的含义。</p><h2 id="1-字符"><a href="#1-字符" class="headerlink" title="1.字符"></a>1.字符</h2><p>正则表达式中我们可以使用两种字符：</p><ul><li>原义字符：原义文本字符代表字符本身的匹配</li><li>元字符：元字符是正则表达式中有特殊含义的字符，其组合代表特殊字符或者其他逻辑</li></ul><p>在正则表达式中以下字符有特殊含义，为元字符<br>所以只有转义之后它们才能作为原义文本字符来使用：</p><p><code>*</code>, <code>+</code>, <code>?</code>, <code>$</code>, <code>^</code>, <code>.</code>, <code>|</code>, <code>\</code>, <code>()</code>, <code>[]</code>, <code>{}</code></p><p>比如你想要匹配字符串中出现的<code>$</code>, 必须在正则表达式中使用<code>\$</code>进行转义</p><h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>这几个组合而成的元字符组合会匹配相应特殊字符：</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">匹配特殊字符</th></tr></thead><tbody><tr><td style="text-align:center"><code>\t</code></td><td style="text-align:center">制表符</td></tr><tr><td style="text-align:center"><code>\v</code></td><td style="text-align:center">垂直制表符</td></tr><tr><td style="text-align:center"><code>\n</code></td><td style="text-align:center">换行符</td></tr><tr><td style="text-align:center"><code>\r</code></td><td style="text-align:center">回车</td></tr><tr><td style="text-align:center"><code>\f</code></td><td style="text-align:center">换页</td></tr><tr><td style="text-align:center"><code>c*</code></td><td style="text-align:center">Ctrl+特定字符</td></tr></tbody></table><h2 id="2-字符匹配方式"><a href="#2-字符匹配方式" class="headerlink" title="2.字符匹配方式"></a>2.字符匹配方式</h2><h4 id="正常匹配："><a href="#正常匹配：" class="headerlink" title="正常匹配："></a>正常匹配：</h4><p>在正则表达式中使用原义字符或组合成的特殊字符会正常匹配相应字符</p><p>在正则表达式中使用<code>a</code>会匹配文本<code>a1b2ab3</code>中第一个字符<code>a</code>和倒数第三个字符<code>a</code></p><h4 id="字段匹配："><a href="#字段匹配：" class="headerlink" title="字段匹配："></a>字段匹配：</h4><p>在正则表达式中使用连续的原义字符或组合而成的特殊字符会匹配相应字符组合</p><p>在正则表达式中使用<code>ab</code>会匹配文本<code>a1b2ab3</code>中倒数第二三个字符<code>ab</code></p><h4 id="类匹配："><a href="#类匹配：" class="headerlink" title="类匹配："></a>类匹配：</h4><p>在正则表达式中使用元字符：</p><p><code>[ ]</code>: 创建<em>类</em>将匹配<code>[ ]</code>中的任意字符</p><p>类中字符的连写代表<em>或</em>的关系——满足连写的字符其中一者就将会被匹配</p><p>正则表达式中使用<code>[ab]</code>会匹配文本<code>a1b2ab3</code>中所有的<code>a</code>与<code>b</code>字符</p><p>特殊的<em>类</em>：</p><ul><li><code>[^]</code>: 反相匹配——匹配不是<code>[^</code>和<code>]</code>中的任意字符</li><li><code>[a-z]</code>: 小写字母匹配——从<code>a</code>到<code>z</code>的小写英文字符</li><li><code>[A-Z]</code>: 大写字母匹配——从<code>A</code>到<code>Z</code>的大写英文字符</li><li><code>[0-9]</code>: 数字匹配——从<code>0</code>到<code>9</code>的数字字符</li></ul><p>同时有一些等价的元字符方便使用：</p><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">等价类</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">[^\r\n]</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">[0-9]</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">[^0-9]</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">[\t\n\v\f\r]</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">[^\t\n\v\f\r]</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">[a-zA-Z_0-9]</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:center">[^a-zA-Z_0-9]</td></tr></tbody></table><p>具体什么含义？根据之前的线索推断一下吧 : )</p><h4 id="量匹配"><a href="#量匹配" class="headerlink" title="量匹配"></a>量匹配</h4><p>有的时候，正则表达式需要对字符出现次数进行匹配，此时我们需要使用量匹配的元字符</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>?</code></td><td style="text-align:center">最多出现一次</td></tr><tr><td style="text-align:center"><code>+</code></td><td style="text-align:center">至少出现一次</td></tr><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">出现任意次</td></tr><tr><td style="text-align:center"><code>{n}</code></td><td style="text-align:center">出现n次</td></tr><tr><td style="text-align:center"><code>{n,m}</code></td><td style="text-align:center">出现n到m次</td></tr><tr><td style="text-align:center"><code>{n,}</code></td><td style="text-align:center">至少出现n次</td></tr></tbody></table><p>还包含其它的逻辑匹配</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center"><code>x(?=y)</code></td><td style="text-align:center">只有当<code>x</code>后面紧跟着<code>y</code>时，才匹配<code>x</code></td></tr><tr><td style="text-align:center"><code>x(?!y)</code></td><td style="text-align:center">只有当<code>x</code>后面不是紧跟着<code>y</code>时，才匹配<code>x</code></td></tr><tr><td style="text-align:center">`x</td><td style="text-align:center">y`</td><td>匹配<code>x</code>或<code>y</code></td></tr></tbody></table><p>量匹配的元字符跟随在字符的后面生效，比如：</p><p><code>T\d?</code>匹配后面最多出现一次数字字符的字符<code>T</code></p><div class="tip"><br>进行<code>{n,m}</code>的匹配时，会出现重复满足匹配条件的情况，<br>用正则表达式<code>a\d{2,4}</code>对字符串<code>a123456</code>进行匹配，<br>会匹配到<code>a12</code>,<code>a123</code>,<code>a1234</code>中的哪个呢？<br></div><p>默认情况下，正则表达式处于贪婪模式，即尽可能多地匹配字符串，因此匹配结果应该是<code>a1234</code></p><p>如果想进入非贪婪模式，需要在量词后面加一个问号：<code>a\d{2,4}?</code>，此时正则表达式一旦匹配成功就不会继续匹配</p><p>此时匹配结果为<code>a12</code></p><h4 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h4><p>在正则表达式中使用<code>()</code>可以在正则表达式中生成“组”</p><p>“组”在字符组合的时候具有相对的优先级：</p><p>当我们的正则表达式复杂的时候，我们需要分组进行元字符和字符的组合：</p><p>比如我们使用<code>[a-z]\d{3}</code>匹配<code>a1b2c3d4</code>就是无效的，因为量匹配仅对其前面的字符有效，这个正则表达式的意思就是匹配一个后面跟随三个数字的字母</p><p>当我们想要匹配另一种含义——“连续出现三次字母+数字时”，我们就需要采用分组匹配的方式：</p><p>使用正则表达式<code>([a-z]\d){3}</code>匹配<code>a1b2c3d4</code>就会得到<code>a1b2c3</code></p><p>同时我们可以使用分组匹配来配合逻辑元字符进行不同逻辑的匹配效果，比如：</p><p>使用正则表达式<code>Hel(lo|en)</code>对字符串<code>Hello Helen!</code>进行匹配，匹配得到的结果为</p><p><code>Hello</code>和<code>Helen</code></p><p>“组”除了优先级的提升，还有其他的特殊效果：</p><p>分组匹配可以在替换的时候配合<code>$</code>进行反向引用，反向引用会在后面的章节进行讲解</p><p>同时也可以通过<code>exec</code>方法被分拣到数组里面（见后面章节）</p><div class="tips"><br>如果我们仅仅想使用括号操作元字符效果的范围，并不想生产分组匹配的“组”并实现相关特殊效果，我们可以使用<code>(?:</code>+内容+<code>)</code>的括号来达成目的<br></div><h4 id="边界匹配"><a href="#边界匹配" class="headerlink" title="边界匹配"></a>边界匹配</h4><p>边界匹配是采用元字符的一种特殊匹配方式：</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>^</code></td><td style="text-align:center">匹配行首的边界</td></tr><tr><td style="text-align:center"><code>$</code></td><td style="text-align:center">匹配行末的边界</td></tr><tr><td style="text-align:center"><code>\b</code></td><td style="text-align:center">匹配单词边界</td></tr><tr><td style="text-align:center"><code>\B</code></td><td style="text-align:center">匹配非单词边界</td></tr></tbody></table><p>这些字符本身并不匹配字符，匹配的是特定的边界</p><p>在字符串<code>There HiThere There</code>中使用（全局模式）</p><ul><li>正则表达式<code>^</code>/<code>$</code>结果替换为<code>#</code> —— <code>#There HiThere There</code> 与 <code>There HiThere There#</code></li><li>正则表达式<code>^T</code>/<code>e$</code>结果替换为<code>#</code> —— <code>#here HiThere There</code> 与 <code>There HiThere Ther#</code></li><li>正则表达式<code>\b</code>结果替换为<code>#</code> —— <code>#There# #HiThere# #There#</code></li><li>正则表达式<code>\bT</code>结果替换为<code>#</code> —— <code>#here HiThere #here</code></li><li>正则表达式<code>\bThere\b</code> —— 匹配第一个单词<code>There</code>与最后一个单词<code>There</code></li><li>正则表达式<code>\BThere\b</code> —— 匹配<code>HiThere</code>里面的<code>There</code></li></ul><p>根据这些规律的提示，加上你自己的练习，掌握边界匹配不需要太多时间。</p><div class="tip"><br>  正则表达式默认会将一段文本中每个换行处转化为<code>\n</code>换行符，而这不会被<code>^</code>和<code>$</code>匹配，除非开启了多行模式。有关多行模式的内容，见下一章节。<br></div><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>修饰符是针对于每个正则表达式设置的属性（它们之间互相不冲突）：</p><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>g</code></td><td style="text-align:center">全局模式：对字符串从头开始不止一次地进行匹配</td></tr><tr><td style="text-align:center"><code>i</code></td><td style="text-align:center">忽略大小写模式：忽略英文字母大小写</td></tr><tr><td style="text-align:center"><code>m</code></td><td style="text-align:center">多行模式：令元字符<code>^</code>和<code>$</code>在多行模式下进行工作（行是由<code>\n</code>或<code>\r</code>分割的）</td></tr><tr><td style="text-align:center"><code>y</code></td><td style="text-align:center">黏性模式：只从<code>lastIndex</code>位置开始匹配（且不试图从任何之后的索引匹配）</td></tr></tbody></table><div class="tip"><br><code>Javascript</code>全局模式下重复匹配会有一些奇怪的事情发生（比如下面这段代码）这是因为<code>lastIndex</code>属性在全局模式下生效，其具体特性见后面的章节<br></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\w/g</span></span><br><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/\w/</span></span><br><span class="line">reg.test(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">reg.test(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line">reg1.test(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">reg1.test(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>而且，前文说过，我们之前的实例全部在默认使用全局模式，如果不在全局模式之下，正则表达式只会匹配字符串从头开始的第一个字符段</p><h2 id="2-JavaScript-中的-RegExp-对象"><a href="#2-JavaScript-中的-RegExp-对象" class="headerlink" title="2.JavaScript 中的 RegExp 对象"></a>2.JavaScript 中的 RegExp 对象</h2><p>在<code>JavaScript</code>中，由<code>/</code>开始，由<code>/</code>结束（或者跟随有效正则修饰符）的字段会被<code>JavaScript</code>编译器正确解析为一个<code>RegExp</code>对象。</p><p>同时<code>//</code> —— 空的正则表达式会被解析为注释</p><p><code>RegExp</code>是<code>JavaScript</code>中的内置对象，其构造函数创建了一个正则表达式对象，用来匹配文本</p><p><code>RegExp</code>的详细特性在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="noopener">mdn</a>上有详细讲解与实例</p><p><code>RegExp</code>有两种构造方式：</p><ul><li>字面量方式</li><li>构造函数方式</li></ul><h4 id="字面量方式"><a href="#字面量方式" class="headerlink" title="字面量方式"></a>字面量方式</h4><blockquote><p><code>RegExp</code>对象的实例由<code>/</code>+正则表达式正文+<code>/</code>+正则表达式修饰符组成</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\bis\b/g</span></span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\bis\\b'</span>, <span class="string">'g'</span>)</span><br></pre></td></tr></table></figure><p><code>RegExp</code>构造函数接受两个参数：</p><ul><li>包含正则表达式的一个字符串（注意在字符串中转义符需要转义输入）</li><li>包含正则表达式修饰符的一个字符串</li></ul><p>因此我们更倾向于使用字面量方式进行 <code>RegExp</code> 实例的构建</p><h4 id="RegExp对象的属性"><a href="#RegExp对象的属性" class="headerlink" title="RegExp对象的属性"></a>RegExp对象的属性</h4><p><code>JavaScript</code>中，<code>RegExp</code>有以下属性：</p><ul><li><code>RegExp.lastIndex</code></li><li><code>RegExp.prototype.global</code></li><li><code>RegExp.prototype.ignoreCase</code></li><li><code>RegExp.prototype.mutiline</code></li><li><code>RegExp.prototype.source</code></li><li><code>RegExp.prototype.sticky</code></li></ul><p>以上属性中，除了<code>lastIndex</code>和<code>source</code>以外，其它属性都描述着<code>RegExp</code>对象的在构造时附件的修饰模式 – 由构造<code>RegExp</code>时附加的修饰符决定（它们都是布尔值）</p><p><code>source</code>属性是<code>RegExp</code>对象正则表达式正文的字符串 —— 正则表达式<code>/</code>内部的内容</p><p><code>lastIndex</code>是个复杂的属性，它相当<code>RegExp</code>上的一个标记，它可写，指定着下一次匹配的起始索引位置，同时也是匹配的上一次结果尾部后一个字符的索引位置（只有在全局模式下该属性才有效）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\w/</span></span><br><span class="line"><span class="keyword">while</span>(reg.test(<span class="string">'abc'</span>))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reg.lastIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果为<code>1</code>,<code>2</code>,<code>3</code></p><p>全局正则表达式的匹配可以配合<code>lastIndex</code>进行匹配异步的驱动</p><p>有很多与正则表达式有关的方法可以让我们更轻松地进行字符串操作：</p><h4 id="RegExp对象的方法"><a href="#RegExp对象的方法" class="headerlink" title="RegExp对象的方法"></a>RegExp对象的方法</h4><p><code>JavaScript</code>中，<code>RegExp</code>有以下方法：</p><ul><li><code>RegExp.prototype.exec()</code></li><li><code>RegExp.prototype.test()</code></li><li><code>RegExp.prototype.toString()</code></li></ul><p><code>exec</code>方法接受一个字符串作为参数，返回一个数组：</p><ul><li>第一个元素是正则表达式匹配到的文本</li><li>之后的元素都是依次排列的，正则表达式中从前到后每个分组匹配到的文本</li><li>数组中存在两个索引：<ul><li><code>index</code>: 匹配到字段开始的索引</li><li><code>input</code>: 匹配的整体字符串</li></ul></li><li>正则表达式匹配不到返回<code>null</code></li></ul><p>全局模式<code>RegExp</code>对象调用<code>exec</code>时，可以多次执行<code>exec</code>方法来查找同一个字符串中的其它的成功匹配，每次<code>exec</code>都会更新<code>lastIndex</code>属性</p><p><code>test</code>方法接受一个字符串作为参数，如果正则表达式可以匹配到字符串里的字段，返回<code>true</code>，否则返回<code>false</code></p><p><code>exec</code>方法和<code>test</code>方法在全局的<code>RegExp</code>对象执行时都会更新<code>lastIndex</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\w\d/g</span>,</span><br><span class="line">  str = <span class="string">'a1b2c3d4'</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex) <span class="comment">//0</span></span><br><span class="line">reg.test(str) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex) <span class="comment">//2</span></span><br><span class="line">reg.exec(str) <span class="comment">// [ 'b2', index: 2, input: 'a1b2c3d4'  ]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>这个表格是测试后的<code>lastIndex</code>变化规律：</p><table><thead><tr><th style="text-align:center"><code>lastIndex</code>索引范围</th><th style="text-align:center">下一次匹配结果</th><th style="text-align:center">下一次匹配<code>lastIndex</code>的调整</th></tr></thead><tbody><tr><td style="text-align:center">大于字符串的长度</td><td style="text-align:center">一定失败</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">等于字符串的长度，<code>RegExp</code>不匹配空字符串</td><td style="text-align:center">一定失败</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">等于字符串的长度，<code>RegExp</code>匹配空字符串</td><td style="text-align:center">成功匹配到空字符串</td><td style="text-align:center">不变</td></tr><tr><td style="text-align:center">小于字符串的长度</td><td style="text-align:center">在索引位置向后进行匹配的结果</td><td style="text-align:center">下一次匹配到字段的后一位，匹配不到则归0</td></tr></tbody></table><p><code>toString</code>方法则返回是正则表达式的全文的字符串</p><h4 id="其他与RegExp对象相关的方法"><a href="#其他与RegExp对象相关的方法" class="headerlink" title="其他与RegExp对象相关的方法"></a>其他与RegExp对象相关的方法</h4><ul><li><code>String.prototype.match()</code></li><li><code>String.prototype.replace()</code></li><li><code>String.prototype.search()</code></li><li><code>String.prototype.split()</code></li></ul><p><code>match</code>与<code>RegExp</code>的<code>exec</code>方法相似，接受一个<code>RegExp</code>对象为参数，返回一个包含匹配结果的数组：</p><ul><li>在非全局模式下，返回的数组包含和<code>RegExp.exec</code>一样的内容</li><li>在全局模式下，返回包含所有匹配字段的数组</li><li>如果不能匹配到，则返回<code>null</code></li></ul><p><code>replace</code>方法接受两个参数：第一个参数是<code>RegExp</code>或字符串，第二个参数为字符串或函数，字符串调用<code>replace</code>之后会将字符串中第一个参数正则匹配到的/出现的替换为某个字符串，详细请看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="noopener">mdn</a></p><p>第二个参数作为字符串的话可以使用<code>$</code>号来进行反向引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'2016-10-10'</span>.replace(<span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g</span>, <span class="string">'$2$3$1'</span>)</span><br><span class="line"><span class="comment">// 10102016</span></span><br><span class="line"><span class="string">'2016-10-10'</span>.replace(<span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g</span>, <span class="string">'\$2\$3\$1'</span>)</span><br></pre></td></tr></table></figure><p>除了分组匹配，还有：</p><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:center">代表的值</th></tr></thead><tbody><tr><td style="text-align:center"><code>$$</code></td><td style="text-align:center">插入个<code>$</code></td></tr><tr><td style="text-align:center"><code>$&amp;</code></td><td style="text-align:center">插入匹配的子串</td></tr><tr><td style="text-align:center">`$``</td><td style="text-align:center">插入当前匹配的子串左边的内容</td></tr><tr><td style="text-align:center"><code>$&#39;</code></td><td style="text-align:center">插入当前匹配的子串右边的内容</td></tr></tbody></table><p>第二个参数作为函数的话有这几个（至少三个以上）个参数：</p><ul><li>第<code>1</code>个参数：匹配到的文本字符串</li><li>第<code>2</code>到第<code>n</code>个参数：分组匹配到的内容（设进行了<code>n-1</code>次分组匹配）</li><li>第<code>n+1</code>个参数：匹配项在字符串中的<code>index</code></li><li>第<code>n+2</code>个参数：原字符串</li></ul><div class="tip"><br>  <code>replace</code>的第一个参数，我们如果提供字符串作为参数，就会被自动转化为<code>RegExp</code>对象 —— 不附带任何修饰模式，实例如下： </div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a1a2a3a4'</span>.replace(<span class="string">'a'</span>,<span class="string">'b'</span>) <span class="comment">//b1a2a3a4</span></span><br><span class="line"><span class="string">'a1a2a3a4'</span>.replace(<span class="regexp">/a/g</span>,<span class="string">'b'</span>) <span class="comment">//b1b2b3b4</span></span><br></pre></td></tr></table></figure><p><code>search</code>方法与<code>RegExp</code>的<code>test</code>相似，<br>接受一个<code>RegExp</code>对象为参数，但是返回值为第一次匹配到字段的索引数值（如果没有匹配到则返回<code>-1</code>）</p><p><code>split</code>方法接受两个参数，第一个参数为分隔符（可以是字符串和<code>RegExp</code>），第二个参数为片段数量的限定值（可选），返回一个由一个个分隔符之间的字段组成的数组</p><p>如果不存在有效参数，则返回整个字符串在第一位的数组</p><p>如果分隔符是一个空字符串，则会把原字符串中每个字符的装在数组里返回</p><p>如果分隔符是包含分组匹配的正则表达式，则每次匹配到结果时，分组匹配到的结果也会插入到返回的数组中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/\*/</span>,</span><br><span class="line">  reg2 = <span class="regexp">/(\*)/</span>,</span><br><span class="line">  str = <span class="string">'c*x*y'</span></span><br><span class="line">str.split(reg1) <span class="comment">// ["c", "x", "y"]</span></span><br><span class="line">str.split(reg2) <span class="comment">// ["c", "*", "x", "*", "y"]</span></span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>写了这么多，笔者相信你们头都晕了 : )</p><p>记住正则表达式的关键：</p><p>在<code>Javascript</code>中</p><p>正则表达式是用来进行文本匹配相关操作的一个特殊的内建对象</p><ul><li>匹配自身的的原义字符</li><li>匹配特殊字符或者调整匹配逻辑的元字符</li></ul><p>这两种字符的组合成正则表达式的正文，配合修饰符，去匹配字符串中的文本字段</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都爱正则表达式，但是一个个奇怪字符的组合总是让我这种弱鸡感到难以领悟。&lt;/p&gt;
&lt;p&gt;每次看到一个正则匹配式却理解不了，我都安慰自己：“反正我已经知道它是用来匹配文本的”&lt;/p&gt;
&lt;p&gt;为什么不现在直接把它学会呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://lumpychen.github.io/tags/Javascript/"/>
    
      <category term="develop" scheme="http://lumpychen.github.io/tags/develop/"/>
    
  </entry>
  
  <entry>
    <title>Apollo样式测试</title>
    <link href="http://lumpychen.github.io/2016/zh-cn/Apollo%E6%A0%B7%E5%BC%8F%E6%B5%8B%E8%AF%95/"/>
    <id>http://lumpychen.github.io/2016/zh-cn/Apollo样式测试/</id>
    <published>2016-09-17T07:03:29.000Z</published>
    <updated>2016-09-18T01:40:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p>我可以在这里写一点东西作为主页的摘要，然而不方便融入<code>Markdown</code>语法的规范。<br><a id="more"></a></p><hr><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p><em>斜体字</em></p><p><strong> 粗体字</strong></p><p>无序列表：</p><ul><li>无序1</li><li>无序2</li><li>无序3</li></ul><p>有序列表：</p><ol><li>有序1</li><li>有序2</li><li>有序3<ol><li>缩进层级1<ol><li>缩进层级2</li></ol></li></ol></li></ol><blockquote><p>“我引用了一段话。”</p></blockquote><blockquote><p>“我引用了自己所说的一段话。”</p><footer><strong>@Lumpy -</strong><cite><a href="http://www.lumpychen.com" target="_blank" rel="noopener">www.lumpychen.com</a></cite></footer></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="string">'lumpy'</span></span><br><span class="line"><span class="keyword">const</span> speakName = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> speakName</span><br></pre></td></tr></table></figure><p>我写了一段<code>JavaScript</code>代码。</p><p>$$\frac{1}{9}\int_{1}^{10}X^2$$</p><p>我写了一个数学公式，<code>MathJax</code>发挥了它的效果。</p><div class="tip">而这里有一些要注意的地方。</div><p>表格</p><table><thead><tr><th style="text-align:center">存货种类</th><th style="text-align:center">仓库1</th><th style="text-align:center">仓库2</th></tr></thead><tbody><tr><td style="text-align:center">面包</td><td style="text-align:center">100</td><td style="text-align:center">200</td></tr><tr><td style="text-align:center">火腿</td><td style="text-align:center">90</td><td style="text-align:center">102</td></tr></tbody></table><p>我们别忘了插入音乐</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="http://music.163.com/outchain/player?type=2&id=2309174&auto=1&height=32"></iframe><p>以及图片</p><p><img src="http://cdn.quotesgram.com/img/0/51/2004674841-i-was-born-to-make-mistakes-a-drake-quotes-about-love-wonderful-drake-quotes-about-love-930x620.jpg" alt="jaime"></p><p>甚至视频</p><div class="owl-media owl-video owl-bilibili"><embed src="http://static.hdslb.com/miniloader.swf" flashvars="aid=6320264&page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" type="application/x-shockwave-flash" quality="high" allowfullscreen="true"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我可以在这里写一点东西作为主页的摘要，然而不方便融入&lt;code&gt;Markdown&lt;/code&gt;语法的规范。&lt;br&gt;
    
    </summary>
    
    
      <category term="useless" scheme="http://lumpychen.github.io/tags/useless/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://lumpychen.github.io/2016/en/hello-world/"/>
    <id>http://lumpychen.github.io/2016/en/hello-world/</id>
    <published>2016-09-17T07:03:29.000Z</published>
    <updated>2017-12-09T15:23:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/owl.css"><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; href=&quot;/owl.css&quot;&gt;&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very f
      
    
    </summary>
    
    
      <category term="useless" scheme="http://lumpychen.github.io/tags/useless/"/>
    
      <category term="en" scheme="http://lumpychen.github.io/tags/en/"/>
    
  </entry>
  
</feed>
